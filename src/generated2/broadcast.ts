// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v6.31.1
// source: broadcast.proto
/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire';
import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

import {
    GameSnapshot,
    GameSnapshot_State,
    Player,
    Team_Side,
    gameSnapshot_StateFromJSON,
    gameSnapshot_StateToJSON,
    team_SideFromJSON,
    team_SideToJSON,
} from './server.js';

export const protobufPackage = 'lugo';

export interface WatcherRequest {
    /** Not used on localhost */
    uuid: string;
}

export interface StartRequest {
    /** Not used on localhost */
    watcherUuid: string;
}

/** Brings the game snapshot and the event in a specialised format. */
export interface GameEvent {
    /** Game snapshot after the event has happened. */
    gameSnapshot: GameSnapshot | undefined;
    newPlayer?: EventNewPlayer | undefined;
    lostPlayer?: EventLostPlayer | undefined;
    stateChange?: EventStateChange | undefined;
    goal?: EventGoal | undefined;
    gameOver?: EventGameOver | undefined;
    breakpoint?: EventDebugBreakpoint | undefined;
    debugReleased?: EventDebugReleased | undefined;
}

export interface GameSetup {
    /**
     * Defines the communication protocol version between the players and the game server.
     * The players also inform to the server what protocol they will use. If incompatible, the server will reject the player.
     */
    protocolVersion: string;
    devMode: boolean;
    startMode: GameSetup_StartingMode;
    listeningMode: GameSetup_ListeningMode;
    /** in milliseconds */
    listeningDuration: number;
    gameDuration: number;
    homeTeam: TeamSettings | undefined;
    awayTeam: TeamSettings | undefined;
}

export enum GameSetup_StartingMode {
    /** NO_WAIT - start the game as soon as all players are connected */
    NO_WAIT = 0,
    /** WAIT - do not start until the master watcher request (gRPC call to Broadcast service) */
    WAIT = 1,
    UNRECOGNIZED = -1,
}

export function gameSetup_StartingModeFromJSON(object: any): GameSetup_StartingMode {
    switch (object) {
        case 0:
        case 'NO_WAIT':
            return GameSetup_StartingMode.NO_WAIT;
        case 1:
        case 'WAIT':
            return GameSetup_StartingMode.WAIT;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return GameSetup_StartingMode.UNRECOGNIZED;
    }
}

export function gameSetup_StartingModeToJSON(object: GameSetup_StartingMode): string {
    switch (object) {
        case GameSetup_StartingMode.NO_WAIT:
            return 'NO_WAIT';
        case GameSetup_StartingMode.WAIT:
            return 'WAIT';
        case GameSetup_StartingMode.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}

export enum GameSetup_ListeningMode {
    /** TIMER - respect the timer defined by listening duration */
    TIMER = 0,
    /** RUSH - immediately after all orders */
    RUSH = 1,
    /** REMOTE - wait external remote control (dev only) */
    REMOTE = 2,
    UNRECOGNIZED = -1,
}

export function gameSetup_ListeningModeFromJSON(object: any): GameSetup_ListeningMode {
    switch (object) {
        case 0:
        case 'TIMER':
            return GameSetup_ListeningMode.TIMER;
        case 1:
        case 'RUSH':
            return GameSetup_ListeningMode.RUSH;
        case 2:
        case 'REMOTE':
            return GameSetup_ListeningMode.REMOTE;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return GameSetup_ListeningMode.UNRECOGNIZED;
    }
}

export function gameSetup_ListeningModeToJSON(object: GameSetup_ListeningMode): string {
    switch (object) {
        case GameSetup_ListeningMode.TIMER:
            return 'TIMER';
        case GameSetup_ListeningMode.RUSH:
            return 'RUSH';
        case GameSetup_ListeningMode.REMOTE:
            return 'REMOTE';
        case GameSetup_ListeningMode.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}

export interface TeamSettings {
    name: string;
    avatar: string;
    colors: TeamColors | undefined;
}

export interface TeamColors {
    primary: TeamColor | undefined;
    secondary: TeamColor | undefined;
}

export interface TeamColor {
    red: number;
    green: number;
    blue: number;
}

/** Represents the event of having a new player connected to the game. */
export interface EventNewPlayer {
    /** Player that has connected to the game. */
    player: Player | undefined;
}

/** Represents the event of having a player disconnected from the game. */
export interface EventLostPlayer {
    /** Player that has disconnected from the game. */
    player: Player | undefined;
}

/** Represents the event of having the game state changed (e.g. from Waiting to GetReady). */
export interface EventStateChange {
    /** State of the game before the event. */
    previousState: GameSnapshot_State;
    /** State of the game after the event. */
    newState: GameSnapshot_State;
}

/** Represents the event of having a goal during the match */
export interface EventGoal {
    /** Side of the team that changed the score. */
    side: Team_Side;
}

/** Represents the event of having the game ended. */
export interface EventGameOver {
    /** Reason for the end of the game */
    reason: EventGameOver_EndingReason;
    /** Which team was responsible to cause the game to be interrupted */
    blame: EventGameOver_BlameStop;
}

export enum EventGameOver_EndingReason {
    /** TIME_IS_OVER - Normal ending, the game ran until the end of the expected number of turns */
    TIME_IS_OVER = 0,
    /** WAITING_EXPIRED - The game did not start. One of the teams or both teams do not have 11 bots connected */
    WAITING_EXPIRED = 1,
    /** NO_ENOUGH_PLAYER - The game was interrupted because too many bots of at least one team disconnected. */
    NO_ENOUGH_PLAYER = 2,
    /** EXTERNAL_REQUEST - The game was interrupted by an external command (it was stopped) */
    EXTERNAL_REQUEST = 3,
    /**
     * KNOCKOUT - The game was interrupted because the score difference is too large to the remaining time.
     * Blame the knocked out team
     */
    KNOCKOUT = 4,
    UNRECOGNIZED = -1,
}

export function eventGameOver_EndingReasonFromJSON(object: any): EventGameOver_EndingReason {
    switch (object) {
        case 0:
        case 'TIME_IS_OVER':
            return EventGameOver_EndingReason.TIME_IS_OVER;
        case 1:
        case 'WAITING_EXPIRED':
            return EventGameOver_EndingReason.WAITING_EXPIRED;
        case 2:
        case 'NO_ENOUGH_PLAYER':
            return EventGameOver_EndingReason.NO_ENOUGH_PLAYER;
        case 3:
        case 'EXTERNAL_REQUEST':
            return EventGameOver_EndingReason.EXTERNAL_REQUEST;
        case 4:
        case 'KNOCKOUT':
            return EventGameOver_EndingReason.KNOCKOUT;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return EventGameOver_EndingReason.UNRECOGNIZED;
    }
}

export function eventGameOver_EndingReasonToJSON(object: EventGameOver_EndingReason): string {
    switch (object) {
        case EventGameOver_EndingReason.TIME_IS_OVER:
            return 'TIME_IS_OVER';
        case EventGameOver_EndingReason.WAITING_EXPIRED:
            return 'WAITING_EXPIRED';
        case EventGameOver_EndingReason.NO_ENOUGH_PLAYER:
            return 'NO_ENOUGH_PLAYER';
        case EventGameOver_EndingReason.EXTERNAL_REQUEST:
            return 'EXTERNAL_REQUEST';
        case EventGameOver_EndingReason.KNOCKOUT:
            return 'KNOCKOUT';
        case EventGameOver_EndingReason.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}

export enum EventGameOver_BlameStop {
    NORMAL = 0,
    BOTH_TEAMS = 1,
    HOME_TEAM = 2,
    AWAY_TEAM = 3,
    UNRECOGNIZED = -1,
}

export function eventGameOver_BlameStopFromJSON(object: any): EventGameOver_BlameStop {
    switch (object) {
        case 0:
        case 'NORMAL':
            return EventGameOver_BlameStop.NORMAL;
        case 1:
        case 'BOTH_TEAMS':
            return EventGameOver_BlameStop.BOTH_TEAMS;
        case 2:
        case 'HOME_TEAM':
            return EventGameOver_BlameStop.HOME_TEAM;
        case 3:
        case 'AWAY_TEAM':
            return EventGameOver_BlameStop.AWAY_TEAM;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return EventGameOver_BlameStop.UNRECOGNIZED;
    }
}

export function eventGameOver_BlameStopToJSON(object: EventGameOver_BlameStop): string {
    switch (object) {
        case EventGameOver_BlameStop.NORMAL:
            return 'NORMAL';
        case EventGameOver_BlameStop.BOTH_TEAMS:
            return 'BOTH_TEAMS';
        case EventGameOver_BlameStop.HOME_TEAM:
            return 'HOME_TEAM';
        case EventGameOver_BlameStop.AWAY_TEAM:
            return 'AWAY_TEAM';
        case EventGameOver_BlameStop.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}

/** (only available dev mode) Represents the event of having a breakpoint reached. */
export interface EventDebugBreakpoint {
    /** Type of the breakpoint reached. */
    breakpoint: EventDebugBreakpoint_Breakpoint;
}

export enum EventDebugBreakpoint_Breakpoint {
    /**
     * ORDERS - Breakpoint that breaks the game before each player orders set be processed during the "Playing" state
     * Each player's order set will be processed at once, so the breakpoint controls the process based on
     * players, not on orders.
     */
    ORDERS = 0,
    /** TURN - Breakpoint that breaks the game before each player turn be processed during the "Playing" state */
    TURN = 1,
    UNRECOGNIZED = -1,
}

export function eventDebugBreakpoint_BreakpointFromJSON(object: any): EventDebugBreakpoint_Breakpoint {
    switch (object) {
        case 0:
        case 'ORDERS':
            return EventDebugBreakpoint_Breakpoint.ORDERS;
        case 1:
        case 'TURN':
            return EventDebugBreakpoint_Breakpoint.TURN;
        case -1:
        case 'UNRECOGNIZED':
        default:
            return EventDebugBreakpoint_Breakpoint.UNRECOGNIZED;
    }
}

export function eventDebugBreakpoint_BreakpointToJSON(object: EventDebugBreakpoint_Breakpoint): string {
    switch (object) {
        case EventDebugBreakpoint_Breakpoint.ORDERS:
            return 'ORDERS';
        case EventDebugBreakpoint_Breakpoint.TURN:
            return 'TURN';
        case EventDebugBreakpoint_Breakpoint.UNRECOGNIZED:
        default:
            return 'UNRECOGNIZED';
    }
}

/** (only available dev mode) Represents the event of having a breakpoint released. */
export interface EventDebugReleased {}

function createBaseWatcherRequest(): WatcherRequest {
    return { uuid: '' };
}

export const WatcherRequest: MessageFns<WatcherRequest> = {
    encode(message: WatcherRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.uuid !== '') {
            writer.uint32(10).string(message.uuid);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): WatcherRequest {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWatcherRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.uuid = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): WatcherRequest {
        return { uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : '' };
    },

    toJSON(message: WatcherRequest): unknown {
        const obj: any = {};
        if (message.uuid !== '') {
            obj.uuid = message.uuid;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<WatcherRequest>, I>>(base?: I): WatcherRequest {
        return WatcherRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<WatcherRequest>, I>>(object: I): WatcherRequest {
        const message = createBaseWatcherRequest();
        message.uuid = object.uuid ?? '';
        return message;
    },
};

function createBaseStartRequest(): StartRequest {
    return { watcherUuid: '' };
}

export const StartRequest: MessageFns<StartRequest> = {
    encode(message: StartRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.watcherUuid !== '') {
            writer.uint32(10).string(message.watcherUuid);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): StartRequest {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseStartRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.watcherUuid = reader.string();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): StartRequest {
        return { watcherUuid: isSet(object.watcherUuid) ? globalThis.String(object.watcherUuid) : '' };
    },

    toJSON(message: StartRequest): unknown {
        const obj: any = {};
        if (message.watcherUuid !== '') {
            obj.watcherUuid = message.watcherUuid;
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<StartRequest>, I>>(base?: I): StartRequest {
        return StartRequest.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<StartRequest>, I>>(object: I): StartRequest {
        const message = createBaseStartRequest();
        message.watcherUuid = object.watcherUuid ?? '';
        return message;
    },
};

function createBaseGameEvent(): GameEvent {
    return {
        gameSnapshot: undefined,
        newPlayer: undefined,
        lostPlayer: undefined,
        stateChange: undefined,
        goal: undefined,
        gameOver: undefined,
        breakpoint: undefined,
        debugReleased: undefined,
    };
}

export const GameEvent: MessageFns<GameEvent> = {
    encode(message: GameEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.gameSnapshot !== undefined) {
            GameSnapshot.encode(message.gameSnapshot, writer.uint32(10).fork()).join();
        }
        if (message.newPlayer !== undefined) {
            EventNewPlayer.encode(message.newPlayer, writer.uint32(18).fork()).join();
        }
        if (message.lostPlayer !== undefined) {
            EventLostPlayer.encode(message.lostPlayer, writer.uint32(26).fork()).join();
        }
        if (message.stateChange !== undefined) {
            EventStateChange.encode(message.stateChange, writer.uint32(34).fork()).join();
        }
        if (message.goal !== undefined) {
            EventGoal.encode(message.goal, writer.uint32(42).fork()).join();
        }
        if (message.gameOver !== undefined) {
            EventGameOver.encode(message.gameOver, writer.uint32(50).fork()).join();
        }
        if (message.breakpoint !== undefined) {
            EventDebugBreakpoint.encode(message.breakpoint, writer.uint32(58).fork()).join();
        }
        if (message.debugReleased !== undefined) {
            EventDebugReleased.encode(message.debugReleased, writer.uint32(66).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GameEvent {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGameEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.gameSnapshot = GameSnapshot.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.newPlayer = EventNewPlayer.decode(reader, reader.uint32());
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.lostPlayer = EventLostPlayer.decode(reader, reader.uint32());
                    continue;
                }
                case 4: {
                    if (tag !== 34) {
                        break;
                    }

                    message.stateChange = EventStateChange.decode(reader, reader.uint32());
                    continue;
                }
                case 5: {
                    if (tag !== 42) {
                        break;
                    }

                    message.goal = EventGoal.decode(reader, reader.uint32());
                    continue;
                }
                case 6: {
                    if (tag !== 50) {
                        break;
                    }

                    message.gameOver = EventGameOver.decode(reader, reader.uint32());
                    continue;
                }
                case 7: {
                    if (tag !== 58) {
                        break;
                    }

                    message.breakpoint = EventDebugBreakpoint.decode(reader, reader.uint32());
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }

                    message.debugReleased = EventDebugReleased.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): GameEvent {
        return {
            gameSnapshot: isSet(object.gameSnapshot) ? GameSnapshot.fromJSON(object.gameSnapshot) : undefined,
            newPlayer: isSet(object.newPlayer) ? EventNewPlayer.fromJSON(object.newPlayer) : undefined,
            lostPlayer: isSet(object.lostPlayer) ? EventLostPlayer.fromJSON(object.lostPlayer) : undefined,
            stateChange: isSet(object.stateChange) ? EventStateChange.fromJSON(object.stateChange) : undefined,
            goal: isSet(object.goal) ? EventGoal.fromJSON(object.goal) : undefined,
            gameOver: isSet(object.gameOver) ? EventGameOver.fromJSON(object.gameOver) : undefined,
            breakpoint: isSet(object.breakpoint) ? EventDebugBreakpoint.fromJSON(object.breakpoint) : undefined,
            debugReleased: isSet(object.debugReleased) ? EventDebugReleased.fromJSON(object.debugReleased) : undefined,
        };
    },

    toJSON(message: GameEvent): unknown {
        const obj: any = {};
        if (message.gameSnapshot !== undefined) {
            obj.gameSnapshot = GameSnapshot.toJSON(message.gameSnapshot);
        }
        if (message.newPlayer !== undefined) {
            obj.newPlayer = EventNewPlayer.toJSON(message.newPlayer);
        }
        if (message.lostPlayer !== undefined) {
            obj.lostPlayer = EventLostPlayer.toJSON(message.lostPlayer);
        }
        if (message.stateChange !== undefined) {
            obj.stateChange = EventStateChange.toJSON(message.stateChange);
        }
        if (message.goal !== undefined) {
            obj.goal = EventGoal.toJSON(message.goal);
        }
        if (message.gameOver !== undefined) {
            obj.gameOver = EventGameOver.toJSON(message.gameOver);
        }
        if (message.breakpoint !== undefined) {
            obj.breakpoint = EventDebugBreakpoint.toJSON(message.breakpoint);
        }
        if (message.debugReleased !== undefined) {
            obj.debugReleased = EventDebugReleased.toJSON(message.debugReleased);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<GameEvent>, I>>(base?: I): GameEvent {
        return GameEvent.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GameEvent>, I>>(object: I): GameEvent {
        const message = createBaseGameEvent();
        message.gameSnapshot =
            object.gameSnapshot !== undefined && object.gameSnapshot !== null
                ? GameSnapshot.fromPartial(object.gameSnapshot)
                : undefined;
        message.newPlayer =
            object.newPlayer !== undefined && object.newPlayer !== null
                ? EventNewPlayer.fromPartial(object.newPlayer)
                : undefined;
        message.lostPlayer =
            object.lostPlayer !== undefined && object.lostPlayer !== null
                ? EventLostPlayer.fromPartial(object.lostPlayer)
                : undefined;
        message.stateChange =
            object.stateChange !== undefined && object.stateChange !== null
                ? EventStateChange.fromPartial(object.stateChange)
                : undefined;
        message.goal =
            object.goal !== undefined && object.goal !== null ? EventGoal.fromPartial(object.goal) : undefined;
        message.gameOver =
            object.gameOver !== undefined && object.gameOver !== null
                ? EventGameOver.fromPartial(object.gameOver)
                : undefined;
        message.breakpoint =
            object.breakpoint !== undefined && object.breakpoint !== null
                ? EventDebugBreakpoint.fromPartial(object.breakpoint)
                : undefined;
        message.debugReleased =
            object.debugReleased !== undefined && object.debugReleased !== null
                ? EventDebugReleased.fromPartial(object.debugReleased)
                : undefined;
        return message;
    },
};

function createBaseGameSetup(): GameSetup {
    return {
        protocolVersion: '',
        devMode: false,
        startMode: 0,
        listeningMode: 0,
        listeningDuration: 0,
        gameDuration: 0,
        homeTeam: undefined,
        awayTeam: undefined,
    };
}

export const GameSetup: MessageFns<GameSetup> = {
    encode(message: GameSetup, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.protocolVersion !== '') {
            writer.uint32(10).string(message.protocolVersion);
        }
        if (message.devMode !== false) {
            writer.uint32(16).bool(message.devMode);
        }
        if (message.startMode !== 0) {
            writer.uint32(24).int32(message.startMode);
        }
        if (message.listeningMode !== 0) {
            writer.uint32(32).int32(message.listeningMode);
        }
        if (message.listeningDuration !== 0) {
            writer.uint32(40).uint32(message.listeningDuration);
        }
        if (message.gameDuration !== 0) {
            writer.uint32(48).uint32(message.gameDuration);
        }
        if (message.homeTeam !== undefined) {
            TeamSettings.encode(message.homeTeam, writer.uint32(66).fork()).join();
        }
        if (message.awayTeam !== undefined) {
            TeamSettings.encode(message.awayTeam, writer.uint32(74).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): GameSetup {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseGameSetup();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.protocolVersion = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }

                    message.devMode = reader.bool();
                    continue;
                }
                case 3: {
                    if (tag !== 24) {
                        break;
                    }

                    message.startMode = reader.int32() as any;
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }

                    message.listeningMode = reader.int32() as any;
                    continue;
                }
                case 5: {
                    if (tag !== 40) {
                        break;
                    }

                    message.listeningDuration = reader.uint32();
                    continue;
                }
                case 6: {
                    if (tag !== 48) {
                        break;
                    }

                    message.gameDuration = reader.uint32();
                    continue;
                }
                case 8: {
                    if (tag !== 66) {
                        break;
                    }

                    message.homeTeam = TeamSettings.decode(reader, reader.uint32());
                    continue;
                }
                case 9: {
                    if (tag !== 74) {
                        break;
                    }

                    message.awayTeam = TeamSettings.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): GameSetup {
        return {
            protocolVersion: isSet(object.protocolVersion) ? globalThis.String(object.protocolVersion) : '',
            devMode: isSet(object.devMode) ? globalThis.Boolean(object.devMode) : false,
            startMode: isSet(object.startMode) ? gameSetup_StartingModeFromJSON(object.startMode) : 0,
            listeningMode: isSet(object.listeningMode) ? gameSetup_ListeningModeFromJSON(object.listeningMode) : 0,
            listeningDuration: isSet(object.listeningDuration) ? globalThis.Number(object.listeningDuration) : 0,
            gameDuration: isSet(object.gameDuration) ? globalThis.Number(object.gameDuration) : 0,
            homeTeam: isSet(object.homeTeam) ? TeamSettings.fromJSON(object.homeTeam) : undefined,
            awayTeam: isSet(object.awayTeam) ? TeamSettings.fromJSON(object.awayTeam) : undefined,
        };
    },

    toJSON(message: GameSetup): unknown {
        const obj: any = {};
        if (message.protocolVersion !== '') {
            obj.protocolVersion = message.protocolVersion;
        }
        if (message.devMode !== false) {
            obj.devMode = message.devMode;
        }
        if (message.startMode !== 0) {
            obj.startMode = gameSetup_StartingModeToJSON(message.startMode);
        }
        if (message.listeningMode !== 0) {
            obj.listeningMode = gameSetup_ListeningModeToJSON(message.listeningMode);
        }
        if (message.listeningDuration !== 0) {
            obj.listeningDuration = Math.round(message.listeningDuration);
        }
        if (message.gameDuration !== 0) {
            obj.gameDuration = Math.round(message.gameDuration);
        }
        if (message.homeTeam !== undefined) {
            obj.homeTeam = TeamSettings.toJSON(message.homeTeam);
        }
        if (message.awayTeam !== undefined) {
            obj.awayTeam = TeamSettings.toJSON(message.awayTeam);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<GameSetup>, I>>(base?: I): GameSetup {
        return GameSetup.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<GameSetup>, I>>(object: I): GameSetup {
        const message = createBaseGameSetup();
        message.protocolVersion = object.protocolVersion ?? '';
        message.devMode = object.devMode ?? false;
        message.startMode = object.startMode ?? 0;
        message.listeningMode = object.listeningMode ?? 0;
        message.listeningDuration = object.listeningDuration ?? 0;
        message.gameDuration = object.gameDuration ?? 0;
        message.homeTeam =
            object.homeTeam !== undefined && object.homeTeam !== null
                ? TeamSettings.fromPartial(object.homeTeam)
                : undefined;
        message.awayTeam =
            object.awayTeam !== undefined && object.awayTeam !== null
                ? TeamSettings.fromPartial(object.awayTeam)
                : undefined;
        return message;
    },
};

function createBaseTeamSettings(): TeamSettings {
    return { name: '', avatar: '', colors: undefined };
}

export const TeamSettings: MessageFns<TeamSettings> = {
    encode(message: TeamSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.name !== '') {
            writer.uint32(10).string(message.name);
        }
        if (message.avatar !== '') {
            writer.uint32(18).string(message.avatar);
        }
        if (message.colors !== undefined) {
            TeamColors.encode(message.colors, writer.uint32(26).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TeamSettings {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTeamSettings();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.name = reader.string();
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.avatar = reader.string();
                    continue;
                }
                case 3: {
                    if (tag !== 26) {
                        break;
                    }

                    message.colors = TeamColors.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): TeamSettings {
        return {
            name: isSet(object.name) ? globalThis.String(object.name) : '',
            avatar: isSet(object.avatar) ? globalThis.String(object.avatar) : '',
            colors: isSet(object.colors) ? TeamColors.fromJSON(object.colors) : undefined,
        };
    },

    toJSON(message: TeamSettings): unknown {
        const obj: any = {};
        if (message.name !== '') {
            obj.name = message.name;
        }
        if (message.avatar !== '') {
            obj.avatar = message.avatar;
        }
        if (message.colors !== undefined) {
            obj.colors = TeamColors.toJSON(message.colors);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<TeamSettings>, I>>(base?: I): TeamSettings {
        return TeamSettings.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TeamSettings>, I>>(object: I): TeamSettings {
        const message = createBaseTeamSettings();
        message.name = object.name ?? '';
        message.avatar = object.avatar ?? '';
        message.colors =
            object.colors !== undefined && object.colors !== null ? TeamColors.fromPartial(object.colors) : undefined;
        return message;
    },
};

function createBaseTeamColors(): TeamColors {
    return { primary: undefined, secondary: undefined };
}

export const TeamColors: MessageFns<TeamColors> = {
    encode(message: TeamColors, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.primary !== undefined) {
            TeamColor.encode(message.primary, writer.uint32(10).fork()).join();
        }
        if (message.secondary !== undefined) {
            TeamColor.encode(message.secondary, writer.uint32(18).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TeamColors {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTeamColors();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.primary = TeamColor.decode(reader, reader.uint32());
                    continue;
                }
                case 2: {
                    if (tag !== 18) {
                        break;
                    }

                    message.secondary = TeamColor.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): TeamColors {
        return {
            primary: isSet(object.primary) ? TeamColor.fromJSON(object.primary) : undefined,
            secondary: isSet(object.secondary) ? TeamColor.fromJSON(object.secondary) : undefined,
        };
    },

    toJSON(message: TeamColors): unknown {
        const obj: any = {};
        if (message.primary !== undefined) {
            obj.primary = TeamColor.toJSON(message.primary);
        }
        if (message.secondary !== undefined) {
            obj.secondary = TeamColor.toJSON(message.secondary);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<TeamColors>, I>>(base?: I): TeamColors {
        return TeamColors.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TeamColors>, I>>(object: I): TeamColors {
        const message = createBaseTeamColors();
        message.primary =
            object.primary !== undefined && object.primary !== null ? TeamColor.fromPartial(object.primary) : undefined;
        message.secondary =
            object.secondary !== undefined && object.secondary !== null
                ? TeamColor.fromPartial(object.secondary)
                : undefined;
        return message;
    },
};

function createBaseTeamColor(): TeamColor {
    return { red: 0, green: 0, blue: 0 };
}

export const TeamColor: MessageFns<TeamColor> = {
    encode(message: TeamColor, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.red !== 0) {
            writer.uint32(8).uint32(message.red);
        }
        if (message.green !== 0) {
            writer.uint32(16).uint32(message.green);
        }
        if (message.blue !== 0) {
            writer.uint32(32).uint32(message.blue);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): TeamColor {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTeamColor();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.red = reader.uint32();
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }

                    message.green = reader.uint32();
                    continue;
                }
                case 4: {
                    if (tag !== 32) {
                        break;
                    }

                    message.blue = reader.uint32();
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): TeamColor {
        return {
            red: isSet(object.red) ? globalThis.Number(object.red) : 0,
            green: isSet(object.green) ? globalThis.Number(object.green) : 0,
            blue: isSet(object.blue) ? globalThis.Number(object.blue) : 0,
        };
    },

    toJSON(message: TeamColor): unknown {
        const obj: any = {};
        if (message.red !== 0) {
            obj.red = Math.round(message.red);
        }
        if (message.green !== 0) {
            obj.green = Math.round(message.green);
        }
        if (message.blue !== 0) {
            obj.blue = Math.round(message.blue);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<TeamColor>, I>>(base?: I): TeamColor {
        return TeamColor.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<TeamColor>, I>>(object: I): TeamColor {
        const message = createBaseTeamColor();
        message.red = object.red ?? 0;
        message.green = object.green ?? 0;
        message.blue = object.blue ?? 0;
        return message;
    },
};

function createBaseEventNewPlayer(): EventNewPlayer {
    return { player: undefined };
}

export const EventNewPlayer: MessageFns<EventNewPlayer> = {
    encode(message: EventNewPlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.player !== undefined) {
            Player.encode(message.player, writer.uint32(10).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventNewPlayer {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventNewPlayer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.player = Player.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): EventNewPlayer {
        return { player: isSet(object.player) ? Player.fromJSON(object.player) : undefined };
    },

    toJSON(message: EventNewPlayer): unknown {
        const obj: any = {};
        if (message.player !== undefined) {
            obj.player = Player.toJSON(message.player);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<EventNewPlayer>, I>>(base?: I): EventNewPlayer {
        return EventNewPlayer.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventNewPlayer>, I>>(object: I): EventNewPlayer {
        const message = createBaseEventNewPlayer();
        message.player =
            object.player !== undefined && object.player !== null ? Player.fromPartial(object.player) : undefined;
        return message;
    },
};

function createBaseEventLostPlayer(): EventLostPlayer {
    return { player: undefined };
}

export const EventLostPlayer: MessageFns<EventLostPlayer> = {
    encode(message: EventLostPlayer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.player !== undefined) {
            Player.encode(message.player, writer.uint32(10).fork()).join();
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventLostPlayer {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventLostPlayer();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 10) {
                        break;
                    }

                    message.player = Player.decode(reader, reader.uint32());
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): EventLostPlayer {
        return { player: isSet(object.player) ? Player.fromJSON(object.player) : undefined };
    },

    toJSON(message: EventLostPlayer): unknown {
        const obj: any = {};
        if (message.player !== undefined) {
            obj.player = Player.toJSON(message.player);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<EventLostPlayer>, I>>(base?: I): EventLostPlayer {
        return EventLostPlayer.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventLostPlayer>, I>>(object: I): EventLostPlayer {
        const message = createBaseEventLostPlayer();
        message.player =
            object.player !== undefined && object.player !== null ? Player.fromPartial(object.player) : undefined;
        return message;
    },
};

function createBaseEventStateChange(): EventStateChange {
    return { previousState: 0, newState: 0 };
}

export const EventStateChange: MessageFns<EventStateChange> = {
    encode(message: EventStateChange, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.previousState !== 0) {
            writer.uint32(8).int32(message.previousState);
        }
        if (message.newState !== 0) {
            writer.uint32(16).int32(message.newState);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventStateChange {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventStateChange();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.previousState = reader.int32() as any;
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }

                    message.newState = reader.int32() as any;
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): EventStateChange {
        return {
            previousState: isSet(object.previousState) ? gameSnapshot_StateFromJSON(object.previousState) : 0,
            newState: isSet(object.newState) ? gameSnapshot_StateFromJSON(object.newState) : 0,
        };
    },

    toJSON(message: EventStateChange): unknown {
        const obj: any = {};
        if (message.previousState !== 0) {
            obj.previousState = gameSnapshot_StateToJSON(message.previousState);
        }
        if (message.newState !== 0) {
            obj.newState = gameSnapshot_StateToJSON(message.newState);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<EventStateChange>, I>>(base?: I): EventStateChange {
        return EventStateChange.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventStateChange>, I>>(object: I): EventStateChange {
        const message = createBaseEventStateChange();
        message.previousState = object.previousState ?? 0;
        message.newState = object.newState ?? 0;
        return message;
    },
};

function createBaseEventGoal(): EventGoal {
    return { side: 0 };
}

export const EventGoal: MessageFns<EventGoal> = {
    encode(message: EventGoal, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.side !== 0) {
            writer.uint32(8).int32(message.side);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventGoal {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventGoal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.side = reader.int32() as any;
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): EventGoal {
        return { side: isSet(object.side) ? team_SideFromJSON(object.side) : 0 };
    },

    toJSON(message: EventGoal): unknown {
        const obj: any = {};
        if (message.side !== 0) {
            obj.side = team_SideToJSON(message.side);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<EventGoal>, I>>(base?: I): EventGoal {
        return EventGoal.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventGoal>, I>>(object: I): EventGoal {
        const message = createBaseEventGoal();
        message.side = object.side ?? 0;
        return message;
    },
};

function createBaseEventGameOver(): EventGameOver {
    return { reason: 0, blame: 0 };
}

export const EventGameOver: MessageFns<EventGameOver> = {
    encode(message: EventGameOver, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.reason !== 0) {
            writer.uint32(8).int32(message.reason);
        }
        if (message.blame !== 0) {
            writer.uint32(16).int32(message.blame);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventGameOver {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventGameOver();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.reason = reader.int32() as any;
                    continue;
                }
                case 2: {
                    if (tag !== 16) {
                        break;
                    }

                    message.blame = reader.int32() as any;
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): EventGameOver {
        return {
            reason: isSet(object.reason) ? eventGameOver_EndingReasonFromJSON(object.reason) : 0,
            blame: isSet(object.blame) ? eventGameOver_BlameStopFromJSON(object.blame) : 0,
        };
    },

    toJSON(message: EventGameOver): unknown {
        const obj: any = {};
        if (message.reason !== 0) {
            obj.reason = eventGameOver_EndingReasonToJSON(message.reason);
        }
        if (message.blame !== 0) {
            obj.blame = eventGameOver_BlameStopToJSON(message.blame);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<EventGameOver>, I>>(base?: I): EventGameOver {
        return EventGameOver.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventGameOver>, I>>(object: I): EventGameOver {
        const message = createBaseEventGameOver();
        message.reason = object.reason ?? 0;
        message.blame = object.blame ?? 0;
        return message;
    },
};

function createBaseEventDebugBreakpoint(): EventDebugBreakpoint {
    return { breakpoint: 0 };
}

export const EventDebugBreakpoint: MessageFns<EventDebugBreakpoint> = {
    encode(message: EventDebugBreakpoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        if (message.breakpoint !== 0) {
            writer.uint32(8).int32(message.breakpoint);
        }
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventDebugBreakpoint {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventDebugBreakpoint();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1: {
                    if (tag !== 8) {
                        break;
                    }

                    message.breakpoint = reader.int32() as any;
                    continue;
                }
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(object: any): EventDebugBreakpoint {
        return {
            breakpoint: isSet(object.breakpoint) ? eventDebugBreakpoint_BreakpointFromJSON(object.breakpoint) : 0,
        };
    },

    toJSON(message: EventDebugBreakpoint): unknown {
        const obj: any = {};
        if (message.breakpoint !== 0) {
            obj.breakpoint = eventDebugBreakpoint_BreakpointToJSON(message.breakpoint);
        }
        return obj;
    },

    create<I extends Exact<DeepPartial<EventDebugBreakpoint>, I>>(base?: I): EventDebugBreakpoint {
        return EventDebugBreakpoint.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventDebugBreakpoint>, I>>(object: I): EventDebugBreakpoint {
        const message = createBaseEventDebugBreakpoint();
        message.breakpoint = object.breakpoint ?? 0;
        return message;
    },
};

function createBaseEventDebugReleased(): EventDebugReleased {
    return {};
}

export const EventDebugReleased: MessageFns<EventDebugReleased> = {
    encode(_: EventDebugReleased, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
        return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): EventDebugReleased {
        const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEventDebugReleased();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skip(tag & 7);
        }
        return message;
    },

    fromJSON(_: any): EventDebugReleased {
        return {};
    },

    toJSON(_: EventDebugReleased): unknown {
        const obj: any = {};
        return obj;
    },

    create<I extends Exact<DeepPartial<EventDebugReleased>, I>>(base?: I): EventDebugReleased {
        return EventDebugReleased.fromPartial(base ?? ({} as any));
    },
    fromPartial<I extends Exact<DeepPartial<EventDebugReleased>, I>>(_: I): EventDebugReleased {
        const message = createBaseEventDebugReleased();
        return message;
    },
};

/**
 * Service to be consumed by clients (e.g. frontend, app, etc) to watch the match.
 * The game server implements a Broadcast service. This service may help you to control or watch the game during
 * training sessions.
 */
export interface Broadcast {
    /** Keep an open stream that publish all important events in the match. */
    OnEvent(request: WatcherRequest): Observable<GameEvent>;
    /** Returns the game setup configuration. */
    GetGameSetup(request: WatcherRequest): Promise<GameSetup>;
    /**
     * StartGame allows the master watcher to start the match.
     * See the Game Server starting mode to understand how it works.
     */
    StartGame(request: StartRequest): Promise<GameSetup>;
}

export const BroadcastServiceName = 'lugo.Broadcast';
export class BroadcastClientImpl implements Broadcast {
    private readonly rpc: Rpc;
    private readonly service: string;
    constructor(rpc: Rpc, opts?: { service?: string }) {
        this.service = opts?.service || BroadcastServiceName;
        this.rpc = rpc;
        this.OnEvent = this.OnEvent.bind(this);
        this.GetGameSetup = this.GetGameSetup.bind(this);
        this.StartGame = this.StartGame.bind(this);
    }
    OnEvent(request: WatcherRequest): Observable<GameEvent> {
        const data = WatcherRequest.encode(request).finish();
        const result = this.rpc.serverStreamingRequest(this.service, 'OnEvent', data);
        return result.pipe(map((data) => GameEvent.decode(new BinaryReader(data))));
    }

    GetGameSetup(request: WatcherRequest): Promise<GameSetup> {
        const data = WatcherRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, 'GetGameSetup', data);
        return promise.then((data) => GameSetup.decode(new BinaryReader(data)));
    }

    StartGame(request: StartRequest): Promise<GameSetup> {
        const data = StartRequest.encode(request).finish();
        const promise = this.rpc.request(this.service, 'StartGame', data);
        return promise.then((data) => GameSetup.decode(new BinaryReader(data)));
    }
}

interface Rpc {
    request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
    clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
    serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
    bidirectionalStreamingRequest(
        service: string,
        method: string,
        data: Observable<Uint8Array>
    ): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
    ? T
    : T extends globalThis.Array<infer U>
      ? globalThis.Array<DeepPartial<U>>
      : T extends ReadonlyArray<infer U>
        ? ReadonlyArray<DeepPartial<U>>
        : T extends {}
          ? { [K in keyof T]?: DeepPartial<T[K]> }
          : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
    ? P
    : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
    return value !== null && value !== undefined;
}

export interface MessageFns<T> {
    encode(message: T, writer?: BinaryWriter): BinaryWriter;
    decode(input: BinaryReader | Uint8Array, length?: number): T;
    fromJSON(object: any): T;
    toJSON(message: T): unknown;
    create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
    fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
