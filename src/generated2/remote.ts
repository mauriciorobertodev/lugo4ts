// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v6.31.1
// source: remote.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Point, Velocity } from "./physics";
import { GameSnapshot, Player, ShotClock, Team_Side, team_SideFromJSON, team_SideToJSON } from "./server";

export const protobufPackage = "lugo";

export interface PauseResumeRequest {
}

export interface NextTurnRequest {
}

export interface NextOrderRequest {
}

export interface BallProperties {
  position: Point | undefined;
  velocity: Velocity | undefined;
  holder: Player | undefined;
}

export interface PlayerProperties {
  side: Team_Side;
  number: number;
  position: Point | undefined;
  velocity: Velocity | undefined;
}

export interface GameProperties {
  turn: number;
  homeScore: number;
  awayScore: number;
  frameInterval: number;
  shotClock: ShotClock | undefined;
}

export interface CommandResponse {
  code: CommandResponse_StatusCode;
  gameSnapshot: GameSnapshot | undefined;
  details: string;
}

export enum CommandResponse_StatusCode {
  SUCCESS = 0,
  INVALID_VALUE = 1,
  DEADLINE_EXCEEDED = 2,
  OTHER = 99,
  UNRECOGNIZED = -1,
}

export function commandResponse_StatusCodeFromJSON(object: any): CommandResponse_StatusCode {
  switch (object) {
    case 0:
    case "SUCCESS":
      return CommandResponse_StatusCode.SUCCESS;
    case 1:
    case "INVALID_VALUE":
      return CommandResponse_StatusCode.INVALID_VALUE;
    case 2:
    case "DEADLINE_EXCEEDED":
      return CommandResponse_StatusCode.DEADLINE_EXCEEDED;
    case 99:
    case "OTHER":
      return CommandResponse_StatusCode.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CommandResponse_StatusCode.UNRECOGNIZED;
  }
}

export function commandResponse_StatusCodeToJSON(object: CommandResponse_StatusCode): string {
  switch (object) {
    case CommandResponse_StatusCode.SUCCESS:
      return "SUCCESS";
    case CommandResponse_StatusCode.INVALID_VALUE:
      return "INVALID_VALUE";
    case CommandResponse_StatusCode.DEADLINE_EXCEEDED:
      return "DEADLINE_EXCEEDED";
    case CommandResponse_StatusCode.OTHER:
      return "OTHER";
    case CommandResponse_StatusCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ResumeListeningRequest {
}

export interface ResumeListeningResponse {
}

export interface ResetPlayerPositionsRequest {
}

export interface ResetPlayerPositionsResponse {
  gameSnapshot: GameSnapshot | undefined;
}

export interface GameSnapshotRequest {
}

export interface GameSnapshotResponse {
  gameSnapshot: GameSnapshot | undefined;
}

function createBasePauseResumeRequest(): PauseResumeRequest {
  return {};
}

export const PauseResumeRequest: MessageFns<PauseResumeRequest> = {
  encode(_: PauseResumeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PauseResumeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePauseResumeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): PauseResumeRequest {
    return {};
  },

  toJSON(_: PauseResumeRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<PauseResumeRequest>, I>>(base?: I): PauseResumeRequest {
    return PauseResumeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PauseResumeRequest>, I>>(_: I): PauseResumeRequest {
    const message = createBasePauseResumeRequest();
    return message;
  },
};

function createBaseNextTurnRequest(): NextTurnRequest {
  return {};
}

export const NextTurnRequest: MessageFns<NextTurnRequest> = {
  encode(_: NextTurnRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NextTurnRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextTurnRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NextTurnRequest {
    return {};
  },

  toJSON(_: NextTurnRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NextTurnRequest>, I>>(base?: I): NextTurnRequest {
    return NextTurnRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NextTurnRequest>, I>>(_: I): NextTurnRequest {
    const message = createBaseNextTurnRequest();
    return message;
  },
};

function createBaseNextOrderRequest(): NextOrderRequest {
  return {};
}

export const NextOrderRequest: MessageFns<NextOrderRequest> = {
  encode(_: NextOrderRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): NextOrderRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNextOrderRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): NextOrderRequest {
    return {};
  },

  toJSON(_: NextOrderRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<NextOrderRequest>, I>>(base?: I): NextOrderRequest {
    return NextOrderRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<NextOrderRequest>, I>>(_: I): NextOrderRequest {
    const message = createBaseNextOrderRequest();
    return message;
  },
};

function createBaseBallProperties(): BallProperties {
  return { position: undefined, velocity: undefined, holder: undefined };
}

export const BallProperties: MessageFns<BallProperties> = {
  encode(message: BallProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Point.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.velocity !== undefined) {
      Velocity.encode(message.velocity, writer.uint32(18).fork()).join();
    }
    if (message.holder !== undefined) {
      Player.encode(message.holder, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): BallProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBallProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Point.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.velocity = Velocity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.holder = Player.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): BallProperties {
    return {
      position: isSet(object.position) ? Point.fromJSON(object.position) : undefined,
      velocity: isSet(object.velocity) ? Velocity.fromJSON(object.velocity) : undefined,
      holder: isSet(object.holder) ? Player.fromJSON(object.holder) : undefined,
    };
  },

  toJSON(message: BallProperties): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Point.toJSON(message.position);
    }
    if (message.velocity !== undefined) {
      obj.velocity = Velocity.toJSON(message.velocity);
    }
    if (message.holder !== undefined) {
      obj.holder = Player.toJSON(message.holder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<BallProperties>, I>>(base?: I): BallProperties {
    return BallProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<BallProperties>, I>>(object: I): BallProperties {
    const message = createBaseBallProperties();
    message.position = (object.position !== undefined && object.position !== null)
      ? Point.fromPartial(object.position)
      : undefined;
    message.velocity = (object.velocity !== undefined && object.velocity !== null)
      ? Velocity.fromPartial(object.velocity)
      : undefined;
    message.holder = (object.holder !== undefined && object.holder !== null)
      ? Player.fromPartial(object.holder)
      : undefined;
    return message;
  },
};

function createBasePlayerProperties(): PlayerProperties {
  return { side: 0, number: 0, position: undefined, velocity: undefined };
}

export const PlayerProperties: MessageFns<PlayerProperties> = {
  encode(message: PlayerProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.side !== 0) {
      writer.uint32(8).int32(message.side);
    }
    if (message.number !== 0) {
      writer.uint32(16).uint32(message.number);
    }
    if (message.position !== undefined) {
      Point.encode(message.position, writer.uint32(26).fork()).join();
    }
    if (message.velocity !== undefined) {
      Velocity.encode(message.velocity, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PlayerProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayerProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.number = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.position = Point.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.velocity = Velocity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PlayerProperties {
    return {
      side: isSet(object.side) ? team_SideFromJSON(object.side) : 0,
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
      position: isSet(object.position) ? Point.fromJSON(object.position) : undefined,
      velocity: isSet(object.velocity) ? Velocity.fromJSON(object.velocity) : undefined,
    };
  },

  toJSON(message: PlayerProperties): unknown {
    const obj: any = {};
    if (message.side !== 0) {
      obj.side = team_SideToJSON(message.side);
    }
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.position !== undefined) {
      obj.position = Point.toJSON(message.position);
    }
    if (message.velocity !== undefined) {
      obj.velocity = Velocity.toJSON(message.velocity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PlayerProperties>, I>>(base?: I): PlayerProperties {
    return PlayerProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PlayerProperties>, I>>(object: I): PlayerProperties {
    const message = createBasePlayerProperties();
    message.side = object.side ?? 0;
    message.number = object.number ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? Point.fromPartial(object.position)
      : undefined;
    message.velocity = (object.velocity !== undefined && object.velocity !== null)
      ? Velocity.fromPartial(object.velocity)
      : undefined;
    return message;
  },
};

function createBaseGameProperties(): GameProperties {
  return { turn: 0, homeScore: 0, awayScore: 0, frameInterval: 0, shotClock: undefined };
}

export const GameProperties: MessageFns<GameProperties> = {
  encode(message: GameProperties, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.turn !== 0) {
      writer.uint32(8).uint32(message.turn);
    }
    if (message.homeScore !== 0) {
      writer.uint32(16).uint32(message.homeScore);
    }
    if (message.awayScore !== 0) {
      writer.uint32(24).uint32(message.awayScore);
    }
    if (message.frameInterval !== 0) {
      writer.uint32(32).int64(message.frameInterval);
    }
    if (message.shotClock !== undefined) {
      ShotClock.encode(message.shotClock, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameProperties {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameProperties();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.turn = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.homeScore = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.awayScore = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.frameInterval = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.shotClock = ShotClock.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameProperties {
    return {
      turn: isSet(object.turn) ? globalThis.Number(object.turn) : 0,
      homeScore: isSet(object.homeScore) ? globalThis.Number(object.homeScore) : 0,
      awayScore: isSet(object.awayScore) ? globalThis.Number(object.awayScore) : 0,
      frameInterval: isSet(object.frameInterval) ? globalThis.Number(object.frameInterval) : 0,
      shotClock: isSet(object.shotClock) ? ShotClock.fromJSON(object.shotClock) : undefined,
    };
  },

  toJSON(message: GameProperties): unknown {
    const obj: any = {};
    if (message.turn !== 0) {
      obj.turn = Math.round(message.turn);
    }
    if (message.homeScore !== 0) {
      obj.homeScore = Math.round(message.homeScore);
    }
    if (message.awayScore !== 0) {
      obj.awayScore = Math.round(message.awayScore);
    }
    if (message.frameInterval !== 0) {
      obj.frameInterval = Math.round(message.frameInterval);
    }
    if (message.shotClock !== undefined) {
      obj.shotClock = ShotClock.toJSON(message.shotClock);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameProperties>, I>>(base?: I): GameProperties {
    return GameProperties.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameProperties>, I>>(object: I): GameProperties {
    const message = createBaseGameProperties();
    message.turn = object.turn ?? 0;
    message.homeScore = object.homeScore ?? 0;
    message.awayScore = object.awayScore ?? 0;
    message.frameInterval = object.frameInterval ?? 0;
    message.shotClock = (object.shotClock !== undefined && object.shotClock !== null)
      ? ShotClock.fromPartial(object.shotClock)
      : undefined;
    return message;
  },
};

function createBaseCommandResponse(): CommandResponse {
  return { code: 0, gameSnapshot: undefined, details: "" };
}

export const CommandResponse: MessageFns<CommandResponse> = {
  encode(message: CommandResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.gameSnapshot !== undefined) {
      GameSnapshot.encode(message.gameSnapshot, writer.uint32(18).fork()).join();
    }
    if (message.details !== "") {
      writer.uint32(26).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CommandResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCommandResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.gameSnapshot = GameSnapshot.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CommandResponse {
    return {
      code: isSet(object.code) ? commandResponse_StatusCodeFromJSON(object.code) : 0,
      gameSnapshot: isSet(object.gameSnapshot) ? GameSnapshot.fromJSON(object.gameSnapshot) : undefined,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: CommandResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = commandResponse_StatusCodeToJSON(message.code);
    }
    if (message.gameSnapshot !== undefined) {
      obj.gameSnapshot = GameSnapshot.toJSON(message.gameSnapshot);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CommandResponse>, I>>(base?: I): CommandResponse {
    return CommandResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CommandResponse>, I>>(object: I): CommandResponse {
    const message = createBaseCommandResponse();
    message.code = object.code ?? 0;
    message.gameSnapshot = (object.gameSnapshot !== undefined && object.gameSnapshot !== null)
      ? GameSnapshot.fromPartial(object.gameSnapshot)
      : undefined;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseResumeListeningRequest(): ResumeListeningRequest {
  return {};
}

export const ResumeListeningRequest: MessageFns<ResumeListeningRequest> = {
  encode(_: ResumeListeningRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeListeningRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeListeningRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResumeListeningRequest {
    return {};
  },

  toJSON(_: ResumeListeningRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResumeListeningRequest>, I>>(base?: I): ResumeListeningRequest {
    return ResumeListeningRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResumeListeningRequest>, I>>(_: I): ResumeListeningRequest {
    const message = createBaseResumeListeningRequest();
    return message;
  },
};

function createBaseResumeListeningResponse(): ResumeListeningResponse {
  return {};
}

export const ResumeListeningResponse: MessageFns<ResumeListeningResponse> = {
  encode(_: ResumeListeningResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResumeListeningResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResumeListeningResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResumeListeningResponse {
    return {};
  },

  toJSON(_: ResumeListeningResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResumeListeningResponse>, I>>(base?: I): ResumeListeningResponse {
    return ResumeListeningResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResumeListeningResponse>, I>>(_: I): ResumeListeningResponse {
    const message = createBaseResumeListeningResponse();
    return message;
  },
};

function createBaseResetPlayerPositionsRequest(): ResetPlayerPositionsRequest {
  return {};
}

export const ResetPlayerPositionsRequest: MessageFns<ResetPlayerPositionsRequest> = {
  encode(_: ResetPlayerPositionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPlayerPositionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPlayerPositionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ResetPlayerPositionsRequest {
    return {};
  },

  toJSON(_: ResetPlayerPositionsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPlayerPositionsRequest>, I>>(base?: I): ResetPlayerPositionsRequest {
    return ResetPlayerPositionsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPlayerPositionsRequest>, I>>(_: I): ResetPlayerPositionsRequest {
    const message = createBaseResetPlayerPositionsRequest();
    return message;
  },
};

function createBaseResetPlayerPositionsResponse(): ResetPlayerPositionsResponse {
  return { gameSnapshot: undefined };
}

export const ResetPlayerPositionsResponse: MessageFns<ResetPlayerPositionsResponse> = {
  encode(message: ResetPlayerPositionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameSnapshot !== undefined) {
      GameSnapshot.encode(message.gameSnapshot, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ResetPlayerPositionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseResetPlayerPositionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameSnapshot = GameSnapshot.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ResetPlayerPositionsResponse {
    return { gameSnapshot: isSet(object.gameSnapshot) ? GameSnapshot.fromJSON(object.gameSnapshot) : undefined };
  },

  toJSON(message: ResetPlayerPositionsResponse): unknown {
    const obj: any = {};
    if (message.gameSnapshot !== undefined) {
      obj.gameSnapshot = GameSnapshot.toJSON(message.gameSnapshot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ResetPlayerPositionsResponse>, I>>(base?: I): ResetPlayerPositionsResponse {
    return ResetPlayerPositionsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ResetPlayerPositionsResponse>, I>>(object: I): ResetPlayerPositionsResponse {
    const message = createBaseResetPlayerPositionsResponse();
    message.gameSnapshot = (object.gameSnapshot !== undefined && object.gameSnapshot !== null)
      ? GameSnapshot.fromPartial(object.gameSnapshot)
      : undefined;
    return message;
  },
};

function createBaseGameSnapshotRequest(): GameSnapshotRequest {
  return {};
}

export const GameSnapshotRequest: MessageFns<GameSnapshotRequest> = {
  encode(_: GameSnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameSnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GameSnapshotRequest {
    return {};
  },

  toJSON(_: GameSnapshotRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GameSnapshotRequest>, I>>(base?: I): GameSnapshotRequest {
    return GameSnapshotRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameSnapshotRequest>, I>>(_: I): GameSnapshotRequest {
    const message = createBaseGameSnapshotRequest();
    return message;
  },
};

function createBaseGameSnapshotResponse(): GameSnapshotResponse {
  return { gameSnapshot: undefined };
}

export const GameSnapshotResponse: MessageFns<GameSnapshotResponse> = {
  encode(message: GameSnapshotResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.gameSnapshot !== undefined) {
      GameSnapshot.encode(message.gameSnapshot, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameSnapshotResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.gameSnapshot = GameSnapshot.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameSnapshotResponse {
    return { gameSnapshot: isSet(object.gameSnapshot) ? GameSnapshot.fromJSON(object.gameSnapshot) : undefined };
  },

  toJSON(message: GameSnapshotResponse): unknown {
    const obj: any = {};
    if (message.gameSnapshot !== undefined) {
      obj.gameSnapshot = GameSnapshot.toJSON(message.gameSnapshot);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameSnapshotResponse>, I>>(base?: I): GameSnapshotResponse {
    return GameSnapshotResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameSnapshotResponse>, I>>(object: I): GameSnapshotResponse {
    const message = createBaseGameSnapshotResponse();
    message.gameSnapshot = (object.gameSnapshot !== undefined && object.gameSnapshot !== null)
      ? GameSnapshot.fromPartial(object.gameSnapshot)
      : undefined;
    return message;
  },
};

/**
 * The game server implements a Remote service that allows you to control the game flow.
 * This service may help you to control or watch the game during training sessions.
 * The game server only offers this service on debug mode on.
 */
export interface Remote {
  PauseOrResume(request: PauseResumeRequest): Promise<CommandResponse>;
  NextTurn(request: NextTurnRequest): Promise<CommandResponse>;
  NextOrder(request: NextOrderRequest): Promise<CommandResponse>;
  SetBallProperties(request: BallProperties): Promise<CommandResponse>;
  SetPlayerProperties(request: PlayerProperties): Promise<CommandResponse>;
  SetGameProperties(request: GameProperties): Promise<CommandResponse>;
  ResumeListeningPhase(request: ResumeListeningRequest): Promise<ResumeListeningResponse>;
  ResetPlayerPositions(request: ResetPlayerPositionsRequest): Promise<ResetPlayerPositionsResponse>;
  GetGameSnapshot(request: GameSnapshotRequest): Promise<GameSnapshotResponse>;
}

export const RemoteServiceName = "lugo.Remote";
export class RemoteClientImpl implements Remote {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || RemoteServiceName;
    this.rpc = rpc;
    this.PauseOrResume = this.PauseOrResume.bind(this);
    this.NextTurn = this.NextTurn.bind(this);
    this.NextOrder = this.NextOrder.bind(this);
    this.SetBallProperties = this.SetBallProperties.bind(this);
    this.SetPlayerProperties = this.SetPlayerProperties.bind(this);
    this.SetGameProperties = this.SetGameProperties.bind(this);
    this.ResumeListeningPhase = this.ResumeListeningPhase.bind(this);
    this.ResetPlayerPositions = this.ResetPlayerPositions.bind(this);
    this.GetGameSnapshot = this.GetGameSnapshot.bind(this);
  }
  PauseOrResume(request: PauseResumeRequest): Promise<CommandResponse> {
    const data = PauseResumeRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PauseOrResume", data);
    return promise.then((data) => CommandResponse.decode(new BinaryReader(data)));
  }

  NextTurn(request: NextTurnRequest): Promise<CommandResponse> {
    const data = NextTurnRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NextTurn", data);
    return promise.then((data) => CommandResponse.decode(new BinaryReader(data)));
  }

  NextOrder(request: NextOrderRequest): Promise<CommandResponse> {
    const data = NextOrderRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NextOrder", data);
    return promise.then((data) => CommandResponse.decode(new BinaryReader(data)));
  }

  SetBallProperties(request: BallProperties): Promise<CommandResponse> {
    const data = BallProperties.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetBallProperties", data);
    return promise.then((data) => CommandResponse.decode(new BinaryReader(data)));
  }

  SetPlayerProperties(request: PlayerProperties): Promise<CommandResponse> {
    const data = PlayerProperties.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetPlayerProperties", data);
    return promise.then((data) => CommandResponse.decode(new BinaryReader(data)));
  }

  SetGameProperties(request: GameProperties): Promise<CommandResponse> {
    const data = GameProperties.encode(request).finish();
    const promise = this.rpc.request(this.service, "SetGameProperties", data);
    return promise.then((data) => CommandResponse.decode(new BinaryReader(data)));
  }

  ResumeListeningPhase(request: ResumeListeningRequest): Promise<ResumeListeningResponse> {
    const data = ResumeListeningRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResumeListeningPhase", data);
    return promise.then((data) => ResumeListeningResponse.decode(new BinaryReader(data)));
  }

  ResetPlayerPositions(request: ResetPlayerPositionsRequest): Promise<ResetPlayerPositionsResponse> {
    const data = ResetPlayerPositionsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResetPlayerPositions", data);
    return promise.then((data) => ResetPlayerPositionsResponse.decode(new BinaryReader(data)));
  }

  GetGameSnapshot(request: GameSnapshotRequest): Promise<GameSnapshotResponse> {
    const data = GameSnapshotRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "GetGameSnapshot", data);
    return promise.then((data) => GameSnapshotResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
