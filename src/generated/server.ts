// @generated by protobuf-ts 2.11.0
// @generated from protobuf file "server.proto" (package "lugo", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Point, Velocity } from "./physics.js";
/**
 * JoinRequest define the player configuration to the game.
 *
 * @generated from protobuf message lugo.JoinRequest
 */
export interface JoinRequest {
    /**
     * Only used in official matches to guarantee that only one process will assume that player position (team and number).
     * The bot process will receive this token as an argument, and must send it to the server in this message.
     *
     * @generated from protobuf field: string token = 1
     */
    token: string;
    /**
     * Identifies the protocol version of the bot.
     *
     * @generated from protobuf field: string protocol_version = 2
     */
    protocolVersion: string;
    /**
     * Identify the bot's team side (Team_Home or Team_Away)
     *
     * @generated from protobuf field: lugo.Team.Side team_side = 3
     */
    teamSide: Team_Side;
    /**
     * Player's number 1-11
     *
     * @generated from protobuf field: uint32 number = 4
     */
    number: number;
    /**
     * Position where the player must be set at "GetReady" state (at beginning of the match or after a goal)
     *
     * @generated from protobuf field: lugo.Point init_position = 5
     */
    initPosition?: Point;
}
/**
 * GameSnapshot stores all game elements data.
 *
 * @generated from protobuf message lugo.GameSnapshot
 */
export interface GameSnapshot {
    /**
     * The game state defines which phase the game is. The phase determine what the server is doing, are going to do, or
     * what it is waiting for.
     *
     * @generated from protobuf field: lugo.GameSnapshot.State state = 1
     */
    state: GameSnapshot_State;
    /**
     * Turns counter. It starts from 1, but before the match starts, it may be zero.
     *
     * @generated from protobuf field: uint32 turn = 2
     */
    turn: number;
    /**
     * Store the home team elements.
     *
     * @generated from protobuf field: lugo.Team home_team = 3
     */
    homeTeam?: Team;
    /**
     * Store the away team elements.
     *
     * @generated from protobuf field: lugo.Team away_team = 4
     */
    awayTeam?: Team;
    /**
     * Store the ball element.
     *
     * @generated from protobuf field: lugo.Ball ball = 5
     */
    ball?: Ball;
    /**
     * number of turns the ball is in a goal zone
     *
     * @generated from protobuf field: uint32 turns_ball_in_goal_zone = 6
     */
    turnsBallInGoalZone: number;
    /**
     * Store the shot clock to control ball possession limit
     *
     * @generated from protobuf field: lugo.ShotClock shot_clock = 7
     */
    shotClock?: ShotClock;
}
/**
 * @generated from protobuf enum lugo.GameSnapshot.State
 */
export enum GameSnapshot_State {
    /**
     * The game is waiting for all players be connected. There is a configurable time limit to wait for players. After
     * this limit expires, the match is considered over.
     *
     * @generated from protobuf enum value: WAITING = 0;
     */
    WAITING = 0,
    /**
     * The game resets the players position to start the match or to restart the match after a goal.
     *
     * @generated from protobuf enum value: GET_READY = 1;
     */
    GET_READY = 1,
    /**
     * The game is waiting for players orders. There is a configurable time window for this phase. After the time
     * limit expires, the server will ignore the missing orders and process the ones it got.
     * (when running on dev mode, the server may allow different behaviours)
     *
     * @generated from protobuf enum value: LISTENING = 2;
     */
    LISTENING = 2,
    /**
     * The game is executing the players' orders in the same sequence they were gotten.
     * If the ball is NOT been holden, its velocity will be processed first. Otherwise, it position will be updated
     * when the ball holder movement be processed.
     * If there is no movement orders from a player, but it has speed greater than 0, it will be processed after
     * all its orders are processed.
     * Each player orders will be processed in the same sequence they were included in the message (e.g. first move,
     * than kick)
     * The ball kick is processed immediately after the order (the ball position is updated as its new velocity
     * after the kick)
     *
     * @generated from protobuf enum value: PLAYING = 3;
     */
    PLAYING = 3,
    /**
     * The game interrupt the match to shift the ball possession. It happens only when the shot time is over (see
     * shot_clock property). The ball will be given to the goalkeeper of the defense team, and the next state will
     * "listening", so the bots will not have time to rearrange before the next turn.
     *
     * @generated from protobuf enum value: SHIFTING = 4;
     */
    SHIFTING = 4,
    /**
     * The game may be over after any phase.
     * It can be over after Waiting if there is no players connected after the time limit for connections
     * It can be over after GetReady or Listening if there is no enough players (e.g. connection lost)
     * And it also can be over after Playing state if that was the last turn of the match.
     *
     * @generated from protobuf enum value: OVER = 99;
     */
    OVER = 99
}
/**
 * Stores all team elements and data.
 *
 * @generated from protobuf message lugo.Team
 */
export interface Team {
    /**
     * List of player in the team
     *
     * @generated from protobuf field: repeated lugo.Player players = 1
     */
    players: Player[];
    /**
     * Team name
     *
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * Team score in the present turn
     *
     * @generated from protobuf field: uint32 score = 3
     */
    score: number;
    /**
     * Side which the team is playing on.
     *
     * @generated from protobuf field: lugo.Team.Side side = 4
     */
    side: Team_Side;
}
/**
 * @generated from protobuf enum lugo.Team.Side
 */
export enum Team_Side {
    /**
     * Team playing on the left side of field
     *
     * @generated from protobuf enum value: HOME = 0;
     */
    HOME = 0,
    /**
     * Team playing on the right side of the field
     *
     * @generated from protobuf enum value: AWAY = 1;
     */
    AWAY = 1
}
/**
 * Stores the side of the team in attack and the time remaining holding the ball.
 * The team side is changed as soon a bot of the defense team catch the ball.
 *
 * @generated from protobuf message lugo.ShotClock
 */
export interface ShotClock {
    /**
     * Team side of the team in attack.
     *
     * @generated from protobuf field: lugo.Team.Side team_side = 6
     */
    teamSide: Team_Side;
    /**
     * Remaining turns the attack team may hold the ball
     *
     * @generated from protobuf field: uint32 remaining_turns = 7
     */
    remainingTurns: number;
}
/**
 * Stores all player attributes
 *
 * @generated from protobuf message lugo.Player
 */
export interface Player {
    /**
     * Number of this player in its team (1-11)
     *
     * @generated from protobuf field: uint32 number = 1
     */
    number: number;
    /**
     * Current player position
     *
     * @generated from protobuf field: lugo.Point position = 2
     */
    position?: Point;
    /**
     * Current player velocity
     *
     * @generated from protobuf field: lugo.Velocity velocity = 3
     */
    velocity?: Velocity;
    /**
     * Team side which its playing in (it's used to speed up some readings since the player element will be in a list
     * of players of a team)
     *
     * @generated from protobuf field: lugo.Team.Side team_side = 4
     */
    teamSide: Team_Side;
    /**
     * Default position when it's position is reset
     *
     * @generated from protobuf field: lugo.Point init_position = 5
     */
    initPosition?: Point;
    /**
     * indicates the the player is jumping (goalkeepers only)
     *
     * @generated from protobuf field: bool is_jumping = 6
     */
    isJumping: boolean;
}
/**
 * Stores all ball attributes
 *
 * @generated from protobuf message lugo.Ball
 */
export interface Ball {
    /**
     * Current position
     *
     * @generated from protobuf field: lugo.Point position = 1
     */
    position?: Point;
    /**
     * Current velocity. It will be the exactly same velocity as the ball holder when a player is holding it.
     *
     * @generated from protobuf field: lugo.Velocity velocity = 2
     */
    velocity?: Velocity;
    /**
     * Player that is currently holding the ball. Null if the ball is not holden.
     *
     * @generated from protobuf field: lugo.Player holder = 3
     */
    holder?: Player;
}
/**
 * Message sent to the player as a response after sending a order set to the the server.
 *
 * @generated from protobuf message lugo.OrderResponse
 */
export interface OrderResponse {
    /**
     * Define if the order will be correctly processed.
     *
     * @generated from protobuf field: lugo.OrderResponse.StatusCode code = 1
     */
    code: OrderResponse_StatusCode;
    /**
     * String message used for debugging proposes.
     *
     * @generated from protobuf field: string details = 2
     */
    details: string;
}
/**
 * @generated from protobuf enum lugo.OrderResponse.StatusCode
 */
export enum OrderResponse_StatusCode {
    /**
     * @generated from protobuf enum value: SUCCESS = 0;
     */
    SUCCESS = 0,
    /**
     * @generated from protobuf enum value: UNKNOWN_PLAYER = 1;
     */
    UNKNOWN_PLAYER = 1,
    /**
     * @generated from protobuf enum value: NOT_LISTENING = 2;
     */
    NOT_LISTENING = 2,
    /**
     * @generated from protobuf enum value: WRONG_TURN = 3;
     */
    WRONG_TURN = 3,
    /**
     * @generated from protobuf enum value: OTHER = 99;
     */
    OTHER = 99
}
/**
 * Message containing the orders the player want to send to the server in that turn.
 *
 * @generated from protobuf message lugo.OrderSet
 */
export interface OrderSet {
    /**
     * Turn which this order set should be processed at.
     *
     * @generated from protobuf field: uint32 turn = 1
     */
    turn: number;
    /**
     * List of orders in the expected order of execution
     *
     * @generated from protobuf field: repeated lugo.Order orders = 2
     */
    orders: Order[];
    /**
     * String message used for debugging proposes.
     *
     * @generated from protobuf field: string debug_message = 3
     */
    debugMessage: string;
}
/**
 * Order to the game server. To be sent by players during the Listening phase.
 *
 * @generated from protobuf message lugo.Order
 */
export interface Order {
    /**
     * @generated from protobuf oneof: action
     */
    action: {
        oneofKind: "move";
        /**
         * @generated from protobuf field: lugo.Move move = 1
         */
        move: Move;
    } | {
        oneofKind: "catch";
        /**
         * @generated from protobuf field: lugo.Catch catch = 2
         */
        catch: Catch;
    } | {
        oneofKind: "kick";
        /**
         * @generated from protobuf field: lugo.Kick kick = 3
         */
        kick: Kick;
    } | {
        oneofKind: "jump";
        /**
         * @generated from protobuf field: lugo.Jump jump = 4
         */
        jump: Jump;
    } | {
        oneofKind: undefined;
    };
}
/**
 * Order to ask the server to change the player velocity (direction and speed).
 * This order replaces the current player velocity, and the new velocity attribute will be immediately processed
 * in that turn. There is a limit speed to the player. The server will cap the velocity if the request is higher than
 * the limit.
 *
 * @generated from protobuf message lugo.Move
 */
export interface Move {
    /**
     * The nex Velocity
     *
     * @generated from protobuf field: lugo.Velocity velocity = 1
     */
    velocity?: Velocity;
}
/**
 * Order to try to catch the ball. The player can only catch the ball when the player is touching the ball.
 * Only one catching order can be executed in a turn. So, if more than one player try to catch the ball in the same
 * turn, the first processed catch order will succeed, and the next ones will fail.
 *
 * @generated from protobuf message lugo.Catch
 */
export interface Catch {
}
/**
 * The kick order is only executed by the ball holder, and it is processed immediately.
 * Important: The kick velocity is summed to the current ball velocity.
 * The kick speed will suffer a power reduction proportionally to the player direction when the kick is not in the
 * same direction of the player direction. The reduction is calculated based on the angle with the player direction
 * using the formula `SpeedReducerFactor = 0.5 + (0.5 * ((180 - ang) / 180))`
 * In summary, the speed will by reduced proportionally to the angle from 100% at 0 degrees until the limit of
 * 50% at 180 degrees.
 *
 * @generated from protobuf message lugo.Kick
 */
export interface Kick {
    /**
     * Kick velocity (it won't be necessarily the final ball velocity)
     *
     * @generated from protobuf field: lugo.Velocity velocity = 1
     */
    velocity?: Velocity;
}
/**
 * Changes the goalkeepers velocity in a higher speed.
 * The goalkeepers may move kicker than other players when they jump, however the jump movement cannot be interrupted
 * after triggered. (read specs to find out the number of turns the jump lasts)
 *
 * @generated from protobuf message lugo.Jump
 */
export interface Jump {
    /**
     * Goalkeeper's velocity during the jump.
     *
     * @generated from protobuf field: lugo.Velocity velocity = 1
     */
    velocity?: Velocity;
}
// @generated message type with reflection information, may provide speed optimized methods
class JoinRequest$Type extends MessageType<JoinRequest> {
    constructor() {
        super("lugo.JoinRequest", [
            { no: 1, name: "token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "protocol_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "team_side", kind: "enum", T: () => ["lugo.Team.Side", Team_Side] },
            { no: 4, name: "number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "init_position", kind: "message", T: () => Point }
        ]);
    }
    create(value?: PartialMessage<JoinRequest>): JoinRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.token = "";
        message.protocolVersion = "";
        message.teamSide = 0;
        message.number = 0;
        if (value !== undefined)
            reflectionMergePartial<JoinRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: JoinRequest): JoinRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string token */ 1:
                    message.token = reader.string();
                    break;
                case /* string protocol_version */ 2:
                    message.protocolVersion = reader.string();
                    break;
                case /* lugo.Team.Side team_side */ 3:
                    message.teamSide = reader.int32();
                    break;
                case /* uint32 number */ 4:
                    message.number = reader.uint32();
                    break;
                case /* lugo.Point init_position */ 5:
                    message.initPosition = Point.internalBinaryRead(reader, reader.uint32(), options, message.initPosition);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: JoinRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string token = 1; */
        if (message.token !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        /* string protocol_version = 2; */
        if (message.protocolVersion !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.protocolVersion);
        /* lugo.Team.Side team_side = 3; */
        if (message.teamSide !== 0)
            writer.tag(3, WireType.Varint).int32(message.teamSide);
        /* uint32 number = 4; */
        if (message.number !== 0)
            writer.tag(4, WireType.Varint).uint32(message.number);
        /* lugo.Point init_position = 5; */
        if (message.initPosition)
            Point.internalBinaryWrite(message.initPosition, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.JoinRequest
 */
export const JoinRequest = new JoinRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameSnapshot$Type extends MessageType<GameSnapshot> {
    constructor() {
        super("lugo.GameSnapshot", [
            { no: 1, name: "state", kind: "enum", T: () => ["lugo.GameSnapshot.State", GameSnapshot_State] },
            { no: 2, name: "turn", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "home_team", kind: "message", T: () => Team },
            { no: 4, name: "away_team", kind: "message", T: () => Team },
            { no: 5, name: "ball", kind: "message", T: () => Ball },
            { no: 6, name: "turns_ball_in_goal_zone", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "shot_clock", kind: "message", T: () => ShotClock }
        ]);
    }
    create(value?: PartialMessage<GameSnapshot>): GameSnapshot {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.state = 0;
        message.turn = 0;
        message.turnsBallInGoalZone = 0;
        if (value !== undefined)
            reflectionMergePartial<GameSnapshot>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameSnapshot): GameSnapshot {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.GameSnapshot.State state */ 1:
                    message.state = reader.int32();
                    break;
                case /* uint32 turn */ 2:
                    message.turn = reader.uint32();
                    break;
                case /* lugo.Team home_team */ 3:
                    message.homeTeam = Team.internalBinaryRead(reader, reader.uint32(), options, message.homeTeam);
                    break;
                case /* lugo.Team away_team */ 4:
                    message.awayTeam = Team.internalBinaryRead(reader, reader.uint32(), options, message.awayTeam);
                    break;
                case /* lugo.Ball ball */ 5:
                    message.ball = Ball.internalBinaryRead(reader, reader.uint32(), options, message.ball);
                    break;
                case /* uint32 turns_ball_in_goal_zone */ 6:
                    message.turnsBallInGoalZone = reader.uint32();
                    break;
                case /* lugo.ShotClock shot_clock */ 7:
                    message.shotClock = ShotClock.internalBinaryRead(reader, reader.uint32(), options, message.shotClock);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameSnapshot, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.GameSnapshot.State state = 1; */
        if (message.state !== 0)
            writer.tag(1, WireType.Varint).int32(message.state);
        /* uint32 turn = 2; */
        if (message.turn !== 0)
            writer.tag(2, WireType.Varint).uint32(message.turn);
        /* lugo.Team home_team = 3; */
        if (message.homeTeam)
            Team.internalBinaryWrite(message.homeTeam, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Team away_team = 4; */
        if (message.awayTeam)
            Team.internalBinaryWrite(message.awayTeam, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Ball ball = 5; */
        if (message.ball)
            Ball.internalBinaryWrite(message.ball, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* uint32 turns_ball_in_goal_zone = 6; */
        if (message.turnsBallInGoalZone !== 0)
            writer.tag(6, WireType.Varint).uint32(message.turnsBallInGoalZone);
        /* lugo.ShotClock shot_clock = 7; */
        if (message.shotClock)
            ShotClock.internalBinaryWrite(message.shotClock, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.GameSnapshot
 */
export const GameSnapshot = new GameSnapshot$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Team$Type extends MessageType<Team> {
    constructor() {
        super("lugo.Team", [
            { no: 1, name: "players", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Player },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "score", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "side", kind: "enum", T: () => ["lugo.Team.Side", Team_Side] }
        ]);
    }
    create(value?: PartialMessage<Team>): Team {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.players = [];
        message.name = "";
        message.score = 0;
        message.side = 0;
        if (value !== undefined)
            reflectionMergePartial<Team>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Team): Team {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated lugo.Player players */ 1:
                    message.players.push(Player.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* uint32 score */ 3:
                    message.score = reader.uint32();
                    break;
                case /* lugo.Team.Side side */ 4:
                    message.side = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Team, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated lugo.Player players = 1; */
        for (let i = 0; i < message.players.length; i++)
            Player.internalBinaryWrite(message.players[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* uint32 score = 3; */
        if (message.score !== 0)
            writer.tag(3, WireType.Varint).uint32(message.score);
        /* lugo.Team.Side side = 4; */
        if (message.side !== 0)
            writer.tag(4, WireType.Varint).int32(message.side);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Team
 */
export const Team = new Team$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShotClock$Type extends MessageType<ShotClock> {
    constructor() {
        super("lugo.ShotClock", [
            { no: 6, name: "team_side", kind: "enum", T: () => ["lugo.Team.Side", Team_Side] },
            { no: 7, name: "remaining_turns", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ShotClock>): ShotClock {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.teamSide = 0;
        message.remainingTurns = 0;
        if (value !== undefined)
            reflectionMergePartial<ShotClock>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShotClock): ShotClock {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Team.Side team_side */ 6:
                    message.teamSide = reader.int32();
                    break;
                case /* uint32 remaining_turns */ 7:
                    message.remainingTurns = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ShotClock, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Team.Side team_side = 6; */
        if (message.teamSide !== 0)
            writer.tag(6, WireType.Varint).int32(message.teamSide);
        /* uint32 remaining_turns = 7; */
        if (message.remainingTurns !== 0)
            writer.tag(7, WireType.Varint).uint32(message.remainingTurns);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.ShotClock
 */
export const ShotClock = new ShotClock$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Player$Type extends MessageType<Player> {
    constructor() {
        super("lugo.Player", [
            { no: 1, name: "number", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "position", kind: "message", T: () => Point },
            { no: 3, name: "velocity", kind: "message", T: () => Velocity },
            { no: 4, name: "team_side", kind: "enum", T: () => ["lugo.Team.Side", Team_Side] },
            { no: 5, name: "init_position", kind: "message", T: () => Point },
            { no: 6, name: "is_jumping", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<Player>): Player {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.number = 0;
        message.teamSide = 0;
        message.isJumping = false;
        if (value !== undefined)
            reflectionMergePartial<Player>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Player): Player {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 number */ 1:
                    message.number = reader.uint32();
                    break;
                case /* lugo.Point position */ 2:
                    message.position = Point.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* lugo.Velocity velocity */ 3:
                    message.velocity = Velocity.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* lugo.Team.Side team_side */ 4:
                    message.teamSide = reader.int32();
                    break;
                case /* lugo.Point init_position */ 5:
                    message.initPosition = Point.internalBinaryRead(reader, reader.uint32(), options, message.initPosition);
                    break;
                case /* bool is_jumping */ 6:
                    message.isJumping = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Player, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 number = 1; */
        if (message.number !== 0)
            writer.tag(1, WireType.Varint).uint32(message.number);
        /* lugo.Point position = 2; */
        if (message.position)
            Point.internalBinaryWrite(message.position, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Velocity velocity = 3; */
        if (message.velocity)
            Velocity.internalBinaryWrite(message.velocity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Team.Side team_side = 4; */
        if (message.teamSide !== 0)
            writer.tag(4, WireType.Varint).int32(message.teamSide);
        /* lugo.Point init_position = 5; */
        if (message.initPosition)
            Point.internalBinaryWrite(message.initPosition, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* bool is_jumping = 6; */
        if (message.isJumping !== false)
            writer.tag(6, WireType.Varint).bool(message.isJumping);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Player
 */
export const Player = new Player$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Ball$Type extends MessageType<Ball> {
    constructor() {
        super("lugo.Ball", [
            { no: 1, name: "position", kind: "message", T: () => Point },
            { no: 2, name: "velocity", kind: "message", T: () => Velocity },
            { no: 3, name: "holder", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<Ball>): Ball {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Ball>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Ball): Ball {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Point position */ 1:
                    message.position = Point.internalBinaryRead(reader, reader.uint32(), options, message.position);
                    break;
                case /* lugo.Velocity velocity */ 2:
                    message.velocity = Velocity.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                case /* lugo.Player holder */ 3:
                    message.holder = Player.internalBinaryRead(reader, reader.uint32(), options, message.holder);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Ball, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Point position = 1; */
        if (message.position)
            Point.internalBinaryWrite(message.position, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Velocity velocity = 2; */
        if (message.velocity)
            Velocity.internalBinaryWrite(message.velocity, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Player holder = 3; */
        if (message.holder)
            Player.internalBinaryWrite(message.holder, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Ball
 */
export const Ball = new Ball$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderResponse$Type extends MessageType<OrderResponse> {
    constructor() {
        super("lugo.OrderResponse", [
            { no: 1, name: "code", kind: "enum", T: () => ["lugo.OrderResponse.StatusCode", OrderResponse_StatusCode] },
            { no: 2, name: "details", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderResponse>): OrderResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.details = "";
        if (value !== undefined)
            reflectionMergePartial<OrderResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderResponse): OrderResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.OrderResponse.StatusCode code */ 1:
                    message.code = reader.int32();
                    break;
                case /* string details */ 2:
                    message.details = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.OrderResponse.StatusCode code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).int32(message.code);
        /* string details = 2; */
        if (message.details !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.details);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.OrderResponse
 */
export const OrderResponse = new OrderResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderSet$Type extends MessageType<OrderSet> {
    constructor() {
        super("lugo.OrderSet", [
            { no: 1, name: "turn", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "orders", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Order },
            { no: 3, name: "debug_message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OrderSet>): OrderSet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.turn = 0;
        message.orders = [];
        message.debugMessage = "";
        if (value !== undefined)
            reflectionMergePartial<OrderSet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderSet): OrderSet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 turn */ 1:
                    message.turn = reader.uint32();
                    break;
                case /* repeated lugo.Order orders */ 2:
                    message.orders.push(Order.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string debug_message */ 3:
                    message.debugMessage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderSet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 turn = 1; */
        if (message.turn !== 0)
            writer.tag(1, WireType.Varint).uint32(message.turn);
        /* repeated lugo.Order orders = 2; */
        for (let i = 0; i < message.orders.length; i++)
            Order.internalBinaryWrite(message.orders[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string debug_message = 3; */
        if (message.debugMessage !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.debugMessage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.OrderSet
 */
export const OrderSet = new OrderSet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Order$Type extends MessageType<Order> {
    constructor() {
        super("lugo.Order", [
            { no: 1, name: "move", kind: "message", oneof: "action", T: () => Move },
            { no: 2, name: "catch", kind: "message", oneof: "action", T: () => Catch },
            { no: 3, name: "kick", kind: "message", oneof: "action", T: () => Kick },
            { no: 4, name: "jump", kind: "message", oneof: "action", T: () => Jump }
        ]);
    }
    create(value?: PartialMessage<Order>): Order {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.action = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<Order>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Order): Order {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Move move */ 1:
                    message.action = {
                        oneofKind: "move",
                        move: Move.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).move)
                    };
                    break;
                case /* lugo.Catch catch */ 2:
                    message.action = {
                        oneofKind: "catch",
                        catch: Catch.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).catch)
                    };
                    break;
                case /* lugo.Kick kick */ 3:
                    message.action = {
                        oneofKind: "kick",
                        kick: Kick.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).kick)
                    };
                    break;
                case /* lugo.Jump jump */ 4:
                    message.action = {
                        oneofKind: "jump",
                        jump: Jump.internalBinaryRead(reader, reader.uint32(), options, (message.action as any).jump)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Order, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Move move = 1; */
        if (message.action.oneofKind === "move")
            Move.internalBinaryWrite(message.action.move, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Catch catch = 2; */
        if (message.action.oneofKind === "catch")
            Catch.internalBinaryWrite(message.action.catch, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Kick kick = 3; */
        if (message.action.oneofKind === "kick")
            Kick.internalBinaryWrite(message.action.kick, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lugo.Jump jump = 4; */
        if (message.action.oneofKind === "jump")
            Jump.internalBinaryWrite(message.action.jump, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Order
 */
export const Order = new Order$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Move$Type extends MessageType<Move> {
    constructor() {
        super("lugo.Move", [
            { no: 1, name: "velocity", kind: "message", T: () => Velocity }
        ]);
    }
    create(value?: PartialMessage<Move>): Move {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Move>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Move): Move {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Velocity velocity */ 1:
                    message.velocity = Velocity.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Move, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Velocity velocity = 1; */
        if (message.velocity)
            Velocity.internalBinaryWrite(message.velocity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Move
 */
export const Move = new Move$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Catch$Type extends MessageType<Catch> {
    constructor() {
        super("lugo.Catch", []);
    }
    create(value?: PartialMessage<Catch>): Catch {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Catch>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Catch): Catch {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Catch, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Catch
 */
export const Catch = new Catch$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Kick$Type extends MessageType<Kick> {
    constructor() {
        super("lugo.Kick", [
            { no: 1, name: "velocity", kind: "message", T: () => Velocity }
        ]);
    }
    create(value?: PartialMessage<Kick>): Kick {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Kick>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Kick): Kick {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Velocity velocity */ 1:
                    message.velocity = Velocity.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Kick, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Velocity velocity = 1; */
        if (message.velocity)
            Velocity.internalBinaryWrite(message.velocity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Kick
 */
export const Kick = new Kick$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Jump$Type extends MessageType<Jump> {
    constructor() {
        super("lugo.Jump", [
            { no: 1, name: "velocity", kind: "message", T: () => Velocity }
        ]);
    }
    create(value?: PartialMessage<Jump>): Jump {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<Jump>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Jump): Jump {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Velocity velocity */ 1:
                    message.velocity = Velocity.internalBinaryRead(reader, reader.uint32(), options, message.velocity);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Jump, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Velocity velocity = 1; */
        if (message.velocity)
            Velocity.internalBinaryWrite(message.velocity, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.Jump
 */
export const Jump = new Jump$Type();
/**
 * @generated ServiceType for protobuf service lugo.Game
 */
export const Game = new ServiceType("lugo.Game", [
    { name: "JoinATeam", serverStreaming: true, options: {}, I: JoinRequest, O: GameSnapshot },
    { name: "SendOrders", options: {}, I: OrderSet, O: OrderResponse }
]);
