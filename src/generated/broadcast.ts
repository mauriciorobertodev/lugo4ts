// @generated by protobuf-ts 2.11.0
// @generated from protobuf file "broadcast.proto" (package "lugo", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { GameSnapshot, Team_Side,GameSnapshot_State, Player  } from "./server.js";
/**
 * @generated from protobuf message lugo.WatcherRequest
 */
export interface WatcherRequest {
    /**
     * Not used on localhost
     *
     * @generated from protobuf field: string uuid = 1
     */
    uuid: string;
}
/**
 * @generated from protobuf message lugo.StartRequest
 */
export interface StartRequest {
    /**
     * Not used on localhost
     *
     * @generated from protobuf field: string watcher_uuid = 1
     */
    watcherUuid: string;
}
/**
 * Brings the game snapshot and the event in a specialised format.
 *
 * @generated from protobuf message lugo.GameEvent
 */
export interface GameEvent {
    /**
     * Game snapshot after the event has happened.
     *
     * @generated from protobuf field: lugo.GameSnapshot game_snapshot = 1
     */
    gameSnapshot?: GameSnapshot;
    /**
     * @generated from protobuf oneof: event
     */
    event: {
        oneofKind: "newPlayer";
        /**
         * @generated from protobuf field: lugo.EventNewPlayer new_player = 2
         */
        newPlayer: EventNewPlayer;
    } | {
        oneofKind: "lostPlayer";
        /**
         * @generated from protobuf field: lugo.EventLostPlayer lost_player = 3
         */
        lostPlayer: EventLostPlayer;
    } | {
        oneofKind: "stateChange";
        /**
         * @generated from protobuf field: lugo.EventStateChange state_change = 4
         */
        stateChange: EventStateChange;
    } | {
        oneofKind: "goal";
        /**
         * @generated from protobuf field: lugo.EventGoal goal = 5
         */
        goal: EventGoal;
    } | {
        oneofKind: "gameOver";
        /**
         * @generated from protobuf field: lugo.EventGameOver game_over = 6
         */
        gameOver: EventGameOver;
    } | {
        oneofKind: "breakpoint";
        /**
         * @generated from protobuf field: lugo.EventDebugBreakpoint breakpoint = 7
         */
        breakpoint: EventDebugBreakpoint;
    } | {
        oneofKind: "debugReleased";
        /**
         * @generated from protobuf field: lugo.EventDebugReleased debug_released = 8
         */
        debugReleased: EventDebugReleased;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message lugo.GameSetup
 */
export interface GameSetup {
    /**
     * Defines the communication protocol version between the players and the game server.
     * The players also inform to the server what protocol they will use. If incompatible, the server will reject the player.
     *
     * @generated from protobuf field: string protocol_version = 1
     */
    protocolVersion: string;
    /**
     * @generated from protobuf field: bool dev_mode = 2
     */
    devMode: boolean;
    /**
     * @generated from protobuf field: lugo.GameSetup.StartingMode start_mode = 3
     */
    startMode: GameSetup_StartingMode;
    /**
     * @generated from protobuf field: lugo.GameSetup.ListeningMode listening_mode = 4
     */
    listeningMode: GameSetup_ListeningMode;
    /**
     * in milliseconds
     *
     * @generated from protobuf field: uint32 listening_duration = 5
     */
    listeningDuration: number;
    /**
     * @generated from protobuf field: uint32 game_duration = 6
     */
    gameDuration: number;
    /**
     * @generated from protobuf field: lugo.TeamSettings home_team = 8
     */
    homeTeam?: TeamSettings;
    /**
     * @generated from protobuf field: lugo.TeamSettings away_team = 9
     */
    awayTeam?: TeamSettings;
}
/**
 * @generated from protobuf enum lugo.GameSetup.StartingMode
 */
export enum GameSetup_StartingMode {
    /**
     * start the game as soon as all players are connected
     *
     * @generated from protobuf enum value: NO_WAIT = 0;
     */
    NO_WAIT = 0,
    /**
     * do not start until the master watcher request (gRPC call to Broadcast service)
     *
     * @generated from protobuf enum value: WAIT = 1;
     */
    WAIT = 1
}
/**
 * @generated from protobuf enum lugo.GameSetup.ListeningMode
 */
export enum GameSetup_ListeningMode {
    /**
     * respect the timer defined by listening duration
     *
     * @generated from protobuf enum value: TIMER = 0;
     */
    TIMER = 0,
    /**
     * immediately after all orders
     *
     * @generated from protobuf enum value: RUSH = 1;
     */
    RUSH = 1,
    /**
     * wait external remote control (dev only)
     *
     * @generated from protobuf enum value: REMOTE = 2;
     */
    REMOTE = 2
}
/**
 * @generated from protobuf message lugo.TeamSettings
 */
export interface TeamSettings {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string;
    /**
     * @generated from protobuf field: string avatar = 2
     */
    avatar: string;
    /**
     * @generated from protobuf field: lugo.TeamColors colors = 3
     */
    colors?: TeamColors;
}
/**
 * @generated from protobuf message lugo.TeamColors
 */
export interface TeamColors {
    /**
     * @generated from protobuf field: lugo.TeamColor primary = 1
     */
    primary?: TeamColor;
    /**
     * @generated from protobuf field: lugo.TeamColor secondary = 2
     */
    secondary?: TeamColor;
}
/**
 * @generated from protobuf message lugo.TeamColor
 */
export interface TeamColor {
    /**
     * @generated from protobuf field: uint32 red = 1
     */
    red: number;
    /**
     * @generated from protobuf field: uint32 green = 2
     */
    green: number;
    /**
     * @generated from protobuf field: uint32 blue = 4
     */
    blue: number;
}
/**
 * Represents the event of having a new player connected to the game.
 *
 * @generated from protobuf message lugo.EventNewPlayer
 */
export interface EventNewPlayer {
    /**
     * Player that has connected to the game.
     *
     * @generated from protobuf field: lugo.Player player = 1
     */
    player?: Player;
}
/**
 * Represents the event of having a player disconnected from the game.
 *
 * @generated from protobuf message lugo.EventLostPlayer
 */
export interface EventLostPlayer {
    /**
     * Player that has disconnected from the game.
     *
     * @generated from protobuf field: lugo.Player player = 1
     */
    player?: Player;
}
/**
 * Represents the event of having the game state changed (e.g. from Waiting to GetReady).
 *
 * @generated from protobuf message lugo.EventStateChange
 */
export interface EventStateChange {
    /**
     * State of the game before the event.
     *
     * @generated from protobuf field: lugo.GameSnapshot.State previous_state = 1
     */
    previousState: GameSnapshot_State;
    /**
     * State of the game after the event.
     *
     * @generated from protobuf field: lugo.GameSnapshot.State new_state = 2
     */
    newState: GameSnapshot_State;
}
/**
 * Represents the event of having a goal during the match
 *
 * @generated from protobuf message lugo.EventGoal
 */
export interface EventGoal {
    /**
     * Side of the team that changed the score.
     *
     * @generated from protobuf field: lugo.Team.Side side = 1
     */
    side: Team_Side; // @todo implementing the player who scored.
}
/**
 * Represents the event of having the game ended.
 *
 * @generated from protobuf message lugo.EventGameOver
 */
export interface EventGameOver {
    /**
     * Reason for the end of the game
     *
     * @generated from protobuf field: lugo.EventGameOver.EndingReason reason = 1
     */
    reason: EventGameOver_EndingReason;
    /**
     * Which team was responsible to cause the game to be interrupted
     *
     * @generated from protobuf field: lugo.EventGameOver.BlameStop blame = 2
     */
    blame: EventGameOver_BlameStop;
}
/**
 * @generated from protobuf enum lugo.EventGameOver.EndingReason
 */
export enum EventGameOver_EndingReason {
    /**
     * Normal ending, the game ran until the end of the expected number of turns
     *
     * @generated from protobuf enum value: TIME_IS_OVER = 0;
     */
    TIME_IS_OVER = 0,
    /**
     * The game did not start. One of the teams or both teams do not have 11 bots connected
     *
     * @generated from protobuf enum value: WAITING_EXPIRED = 1;
     */
    WAITING_EXPIRED = 1,
    /**
     * The game was interrupted because too many bots of at least one team disconnected.
     *
     * @generated from protobuf enum value: NO_ENOUGH_PLAYER = 2;
     */
    NO_ENOUGH_PLAYER = 2,
    /**
     * The game was interrupted by an external command (it was stopped)
     *
     * @generated from protobuf enum value: EXTERNAL_REQUEST = 3;
     */
    EXTERNAL_REQUEST = 3,
    /**
     * The game was interrupted because the score difference is too large to the remaining time.
     * Blame the knocked out team
     *
     * @generated from protobuf enum value: KNOCKOUT = 4;
     */
    KNOCKOUT = 4
}
/**
 * @generated from protobuf enum lugo.EventGameOver.BlameStop
 */
export enum EventGameOver_BlameStop {
    /**
     * @generated from protobuf enum value: NORMAL = 0;
     */
    NORMAL = 0,
    /**
     * @generated from protobuf enum value: BOTH_TEAMS = 1;
     */
    BOTH_TEAMS = 1,
    /**
     * @generated from protobuf enum value: HOME_TEAM = 2;
     */
    HOME_TEAM = 2,
    /**
     * @generated from protobuf enum value: AWAY_TEAM = 3;
     */
    AWAY_TEAM = 3
}
/**
 * (only available dev mode) Represents the event of having a breakpoint reached.
 *
 * @generated from protobuf message lugo.EventDebugBreakpoint
 */
export interface EventDebugBreakpoint {
    /**
     * Type of the breakpoint reached.
     *
     * @generated from protobuf field: lugo.EventDebugBreakpoint.Breakpoint breakpoint = 1
     */
    breakpoint: EventDebugBreakpoint_Breakpoint;
}
/**
 * @generated from protobuf enum lugo.EventDebugBreakpoint.Breakpoint
 */
export enum EventDebugBreakpoint_Breakpoint {
    /**
     * Breakpoint that breaks the game before each player orders set be processed during the "Playing" state
     * Each player's order set will be processed at once, so the breakpoint controls the process based on
     * players, not on orders.
     *
     * @generated from protobuf enum value: ORDERS = 0;
     */
    ORDERS = 0,
    /**
     * Breakpoint that breaks the game before each player turn be processed during the "Playing" state
     *
     * @generated from protobuf enum value: TURN = 1;
     */
    TURN = 1
}
/**
 * (only available dev mode) Represents the event of having a breakpoint released.
 *
 * @generated from protobuf message lugo.EventDebugReleased
 */
export interface EventDebugReleased {
}
// @generated message type with reflection information, may provide speed optimized methods
class WatcherRequest$Type extends MessageType<WatcherRequest> {
    constructor() {
        super("lugo.WatcherRequest", [
            { no: 1, name: "uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WatcherRequest>): WatcherRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uuid = "";
        if (value !== undefined)
            reflectionMergePartial<WatcherRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WatcherRequest): WatcherRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string uuid */ 1:
                    message.uuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WatcherRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string uuid = 1; */
        if (message.uuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.uuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.WatcherRequest
 */
export const WatcherRequest = new WatcherRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartRequest$Type extends MessageType<StartRequest> {
    constructor() {
        super("lugo.StartRequest", [
            { no: 1, name: "watcher_uuid", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<StartRequest>): StartRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.watcherUuid = "";
        if (value !== undefined)
            reflectionMergePartial<StartRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartRequest): StartRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string watcher_uuid */ 1:
                    message.watcherUuid = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string watcher_uuid = 1; */
        if (message.watcherUuid !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.watcherUuid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.StartRequest
 */
export const StartRequest = new StartRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameEvent$Type extends MessageType<GameEvent> {
    constructor() {
        super("lugo.GameEvent", [
            { no: 1, name: "game_snapshot", kind: "message", T: () => GameSnapshot },
            { no: 2, name: "new_player", kind: "message", oneof: "event", T: () => EventNewPlayer },
            { no: 3, name: "lost_player", kind: "message", oneof: "event", T: () => EventLostPlayer },
            { no: 4, name: "state_change", kind: "message", oneof: "event", T: () => EventStateChange },
            { no: 5, name: "goal", kind: "message", oneof: "event", T: () => EventGoal },
            { no: 6, name: "game_over", kind: "message", oneof: "event", T: () => EventGameOver },
            { no: 7, name: "breakpoint", kind: "message", oneof: "event", T: () => EventDebugBreakpoint },
            { no: 8, name: "debug_released", kind: "message", oneof: "event", T: () => EventDebugReleased }
        ]);
    }
    create(value?: PartialMessage<GameEvent>): GameEvent {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.event = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<GameEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameEvent): GameEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.GameSnapshot game_snapshot */ 1:
                    message.gameSnapshot = GameSnapshot.internalBinaryRead(reader, reader.uint32(), options, message.gameSnapshot);
                    break;
                case /* lugo.EventNewPlayer new_player */ 2:
                    message.event = {
                        oneofKind: "newPlayer",
                        newPlayer: EventNewPlayer.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).newPlayer)
                    };
                    break;
                case /* lugo.EventLostPlayer lost_player */ 3:
                    message.event = {
                        oneofKind: "lostPlayer",
                        lostPlayer: EventLostPlayer.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).lostPlayer)
                    };
                    break;
                case /* lugo.EventStateChange state_change */ 4:
                    message.event = {
                        oneofKind: "stateChange",
                        stateChange: EventStateChange.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).stateChange)
                    };
                    break;
                case /* lugo.EventGoal goal */ 5:
                    message.event = {
                        oneofKind: "goal",
                        goal: EventGoal.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).goal)
                    };
                    break;
                case /* lugo.EventGameOver game_over */ 6:
                    message.event = {
                        oneofKind: "gameOver",
                        gameOver: EventGameOver.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).gameOver)
                    };
                    break;
                case /* lugo.EventDebugBreakpoint breakpoint */ 7:
                    message.event = {
                        oneofKind: "breakpoint",
                        breakpoint: EventDebugBreakpoint.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).breakpoint)
                    };
                    break;
                case /* lugo.EventDebugReleased debug_released */ 8:
                    message.event = {
                        oneofKind: "debugReleased",
                        debugReleased: EventDebugReleased.internalBinaryRead(reader, reader.uint32(), options, (message.event as any).debugReleased)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.GameSnapshot game_snapshot = 1; */
        if (message.gameSnapshot)
            GameSnapshot.internalBinaryWrite(message.gameSnapshot, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lugo.EventNewPlayer new_player = 2; */
        if (message.event.oneofKind === "newPlayer")
            EventNewPlayer.internalBinaryWrite(message.event.newPlayer, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* lugo.EventLostPlayer lost_player = 3; */
        if (message.event.oneofKind === "lostPlayer")
            EventLostPlayer.internalBinaryWrite(message.event.lostPlayer, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* lugo.EventStateChange state_change = 4; */
        if (message.event.oneofKind === "stateChange")
            EventStateChange.internalBinaryWrite(message.event.stateChange, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* lugo.EventGoal goal = 5; */
        if (message.event.oneofKind === "goal")
            EventGoal.internalBinaryWrite(message.event.goal, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* lugo.EventGameOver game_over = 6; */
        if (message.event.oneofKind === "gameOver")
            EventGameOver.internalBinaryWrite(message.event.gameOver, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* lugo.EventDebugBreakpoint breakpoint = 7; */
        if (message.event.oneofKind === "breakpoint")
            EventDebugBreakpoint.internalBinaryWrite(message.event.breakpoint, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* lugo.EventDebugReleased debug_released = 8; */
        if (message.event.oneofKind === "debugReleased")
            EventDebugReleased.internalBinaryWrite(message.event.debugReleased, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.GameEvent
 */
export const GameEvent = new GameEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GameSetup$Type extends MessageType<GameSetup> {
    constructor() {
        super("lugo.GameSetup", [
            { no: 1, name: "protocol_version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "dev_mode", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "start_mode", kind: "enum", T: () => ["lugo.GameSetup.StartingMode", GameSetup_StartingMode] },
            { no: 4, name: "listening_mode", kind: "enum", T: () => ["lugo.GameSetup.ListeningMode", GameSetup_ListeningMode] },
            { no: 5, name: "listening_duration", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 6, name: "game_duration", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 8, name: "home_team", kind: "message", T: () => TeamSettings },
            { no: 9, name: "away_team", kind: "message", T: () => TeamSettings }
        ]);
    }
    create(value?: PartialMessage<GameSetup>): GameSetup {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.protocolVersion = "";
        message.devMode = false;
        message.startMode = 0;
        message.listeningMode = 0;
        message.listeningDuration = 0;
        message.gameDuration = 0;
        if (value !== undefined)
            reflectionMergePartial<GameSetup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GameSetup): GameSetup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string protocol_version */ 1:
                    message.protocolVersion = reader.string();
                    break;
                case /* bool dev_mode */ 2:
                    message.devMode = reader.bool();
                    break;
                case /* lugo.GameSetup.StartingMode start_mode */ 3:
                    message.startMode = reader.int32();
                    break;
                case /* lugo.GameSetup.ListeningMode listening_mode */ 4:
                    message.listeningMode = reader.int32();
                    break;
                case /* uint32 listening_duration */ 5:
                    message.listeningDuration = reader.uint32();
                    break;
                case /* uint32 game_duration */ 6:
                    message.gameDuration = reader.uint32();
                    break;
                case /* lugo.TeamSettings home_team */ 8:
                    message.homeTeam = TeamSettings.internalBinaryRead(reader, reader.uint32(), options, message.homeTeam);
                    break;
                case /* lugo.TeamSettings away_team */ 9:
                    message.awayTeam = TeamSettings.internalBinaryRead(reader, reader.uint32(), options, message.awayTeam);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GameSetup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string protocol_version = 1; */
        if (message.protocolVersion !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.protocolVersion);
        /* bool dev_mode = 2; */
        if (message.devMode !== false)
            writer.tag(2, WireType.Varint).bool(message.devMode);
        /* lugo.GameSetup.StartingMode start_mode = 3; */
        if (message.startMode !== 0)
            writer.tag(3, WireType.Varint).int32(message.startMode);
        /* lugo.GameSetup.ListeningMode listening_mode = 4; */
        if (message.listeningMode !== 0)
            writer.tag(4, WireType.Varint).int32(message.listeningMode);
        /* uint32 listening_duration = 5; */
        if (message.listeningDuration !== 0)
            writer.tag(5, WireType.Varint).uint32(message.listeningDuration);
        /* uint32 game_duration = 6; */
        if (message.gameDuration !== 0)
            writer.tag(6, WireType.Varint).uint32(message.gameDuration);
        /* lugo.TeamSettings home_team = 8; */
        if (message.homeTeam)
            TeamSettings.internalBinaryWrite(message.homeTeam, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* lugo.TeamSettings away_team = 9; */
        if (message.awayTeam)
            TeamSettings.internalBinaryWrite(message.awayTeam, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.GameSetup
 */
export const GameSetup = new GameSetup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamSettings$Type extends MessageType<TeamSettings> {
    constructor() {
        super("lugo.TeamSettings", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "avatar", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "colors", kind: "message", T: () => TeamColors }
        ]);
    }
    create(value?: PartialMessage<TeamSettings>): TeamSettings {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.avatar = "";
        if (value !== undefined)
            reflectionMergePartial<TeamSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamSettings): TeamSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string avatar */ 2:
                    message.avatar = reader.string();
                    break;
                case /* lugo.TeamColors colors */ 3:
                    message.colors = TeamColors.internalBinaryRead(reader, reader.uint32(), options, message.colors);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string avatar = 2; */
        if (message.avatar !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.avatar);
        /* lugo.TeamColors colors = 3; */
        if (message.colors)
            TeamColors.internalBinaryWrite(message.colors, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.TeamSettings
 */
export const TeamSettings = new TeamSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamColors$Type extends MessageType<TeamColors> {
    constructor() {
        super("lugo.TeamColors", [
            { no: 1, name: "primary", kind: "message", T: () => TeamColor },
            { no: 2, name: "secondary", kind: "message", T: () => TeamColor }
        ]);
    }
    create(value?: PartialMessage<TeamColors>): TeamColors {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<TeamColors>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamColors): TeamColors {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.TeamColor primary */ 1:
                    message.primary = TeamColor.internalBinaryRead(reader, reader.uint32(), options, message.primary);
                    break;
                case /* lugo.TeamColor secondary */ 2:
                    message.secondary = TeamColor.internalBinaryRead(reader, reader.uint32(), options, message.secondary);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamColors, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.TeamColor primary = 1; */
        if (message.primary)
            TeamColor.internalBinaryWrite(message.primary, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* lugo.TeamColor secondary = 2; */
        if (message.secondary)
            TeamColor.internalBinaryWrite(message.secondary, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.TeamColors
 */
export const TeamColors = new TeamColors$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamColor$Type extends MessageType<TeamColor> {
    constructor() {
        super("lugo.TeamColor", [
            { no: 1, name: "red", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "green", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "blue", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<TeamColor>): TeamColor {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.red = 0;
        message.green = 0;
        message.blue = 0;
        if (value !== undefined)
            reflectionMergePartial<TeamColor>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamColor): TeamColor {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 red */ 1:
                    message.red = reader.uint32();
                    break;
                case /* uint32 green */ 2:
                    message.green = reader.uint32();
                    break;
                case /* uint32 blue */ 4:
                    message.blue = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamColor, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 red = 1; */
        if (message.red !== 0)
            writer.tag(1, WireType.Varint).uint32(message.red);
        /* uint32 green = 2; */
        if (message.green !== 0)
            writer.tag(2, WireType.Varint).uint32(message.green);
        /* uint32 blue = 4; */
        if (message.blue !== 0)
            writer.tag(4, WireType.Varint).uint32(message.blue);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.TeamColor
 */
export const TeamColor = new TeamColor$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventNewPlayer$Type extends MessageType<EventNewPlayer> {
    constructor() {
        super("lugo.EventNewPlayer", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<EventNewPlayer>): EventNewPlayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventNewPlayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventNewPlayer): EventNewPlayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventNewPlayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.EventNewPlayer
 */
export const EventNewPlayer = new EventNewPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventLostPlayer$Type extends MessageType<EventLostPlayer> {
    constructor() {
        super("lugo.EventLostPlayer", [
            { no: 1, name: "player", kind: "message", T: () => Player }
        ]);
    }
    create(value?: PartialMessage<EventLostPlayer>): EventLostPlayer {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventLostPlayer>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventLostPlayer): EventLostPlayer {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Player player */ 1:
                    message.player = Player.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventLostPlayer, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Player player = 1; */
        if (message.player)
            Player.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.EventLostPlayer
 */
export const EventLostPlayer = new EventLostPlayer$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventStateChange$Type extends MessageType<EventStateChange> {
    constructor() {
        super("lugo.EventStateChange", [
            { no: 1, name: "previous_state", kind: "enum", T: () => ["lugo.GameSnapshot.State", GameSnapshot_State] },
            { no: 2, name: "new_state", kind: "enum", T: () => ["lugo.GameSnapshot.State", GameSnapshot_State] }
        ]);
    }
    create(value?: PartialMessage<EventStateChange>): EventStateChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.previousState = 0;
        message.newState = 0;
        if (value !== undefined)
            reflectionMergePartial<EventStateChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventStateChange): EventStateChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.GameSnapshot.State previous_state */ 1:
                    message.previousState = reader.int32();
                    break;
                case /* lugo.GameSnapshot.State new_state */ 2:
                    message.newState = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventStateChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.GameSnapshot.State previous_state = 1; */
        if (message.previousState !== 0)
            writer.tag(1, WireType.Varint).int32(message.previousState);
        /* lugo.GameSnapshot.State new_state = 2; */
        if (message.newState !== 0)
            writer.tag(2, WireType.Varint).int32(message.newState);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.EventStateChange
 */
export const EventStateChange = new EventStateChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventGoal$Type extends MessageType<EventGoal> {
    constructor() {
        super("lugo.EventGoal", [
            { no: 1, name: "side", kind: "enum", T: () => ["lugo.Team.Side", Team_Side] }
        ]);
    }
    create(value?: PartialMessage<EventGoal>): EventGoal {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.side = 0;
        if (value !== undefined)
            reflectionMergePartial<EventGoal>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventGoal): EventGoal {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.Team.Side side */ 1:
                    message.side = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventGoal, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.Team.Side side = 1; */
        if (message.side !== 0)
            writer.tag(1, WireType.Varint).int32(message.side);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.EventGoal
 */
export const EventGoal = new EventGoal$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventGameOver$Type extends MessageType<EventGameOver> {
    constructor() {
        super("lugo.EventGameOver", [
            { no: 1, name: "reason", kind: "enum", T: () => ["lugo.EventGameOver.EndingReason", EventGameOver_EndingReason] },
            { no: 2, name: "blame", kind: "enum", T: () => ["lugo.EventGameOver.BlameStop", EventGameOver_BlameStop] }
        ]);
    }
    create(value?: PartialMessage<EventGameOver>): EventGameOver {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = 0;
        message.blame = 0;
        if (value !== undefined)
            reflectionMergePartial<EventGameOver>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventGameOver): EventGameOver {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.EventGameOver.EndingReason reason */ 1:
                    message.reason = reader.int32();
                    break;
                case /* lugo.EventGameOver.BlameStop blame */ 2:
                    message.blame = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventGameOver, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.EventGameOver.EndingReason reason = 1; */
        if (message.reason !== 0)
            writer.tag(1, WireType.Varint).int32(message.reason);
        /* lugo.EventGameOver.BlameStop blame = 2; */
        if (message.blame !== 0)
            writer.tag(2, WireType.Varint).int32(message.blame);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.EventGameOver
 */
export const EventGameOver = new EventGameOver$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventDebugBreakpoint$Type extends MessageType<EventDebugBreakpoint> {
    constructor() {
        super("lugo.EventDebugBreakpoint", [
            { no: 1, name: "breakpoint", kind: "enum", T: () => ["lugo.EventDebugBreakpoint.Breakpoint", EventDebugBreakpoint_Breakpoint] }
        ]);
    }
    create(value?: PartialMessage<EventDebugBreakpoint>): EventDebugBreakpoint {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.breakpoint = 0;
        if (value !== undefined)
            reflectionMergePartial<EventDebugBreakpoint>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventDebugBreakpoint): EventDebugBreakpoint {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* lugo.EventDebugBreakpoint.Breakpoint breakpoint */ 1:
                    message.breakpoint = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventDebugBreakpoint, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* lugo.EventDebugBreakpoint.Breakpoint breakpoint = 1; */
        if (message.breakpoint !== 0)
            writer.tag(1, WireType.Varint).int32(message.breakpoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.EventDebugBreakpoint
 */
export const EventDebugBreakpoint = new EventDebugBreakpoint$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EventDebugReleased$Type extends MessageType<EventDebugReleased> {
    constructor() {
        super("lugo.EventDebugReleased", []);
    }
    create(value?: PartialMessage<EventDebugReleased>): EventDebugReleased {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<EventDebugReleased>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EventDebugReleased): EventDebugReleased {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EventDebugReleased, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message lugo.EventDebugReleased
 */
export const EventDebugReleased = new EventDebugReleased$Type();
/**
 * @generated ServiceType for protobuf service lugo.Broadcast
 */
export const Broadcast = new ServiceType("lugo.Broadcast", [
    { name: "OnEvent", serverStreaming: true, options: {}, I: WatcherRequest, O: GameEvent },
    { name: "GetGameSetup", options: {}, I: WatcherRequest, O: GameSetup },
    { name: "StartGame", options: {}, I: StartRequest, O: GameSetup }
]);
