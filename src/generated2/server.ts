// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.2
//   protoc               v6.31.1
// source: server.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Observable } from "rxjs";
import { map } from "rxjs/operators";
import { Point, Velocity } from "./physics";

export const protobufPackage = "lugo";

/** JoinRequest define the player configuration to the game. */
export interface JoinRequest {
  /**
   * Only used in official matches to guarantee that only one process will assume that player position (team and number).
   * The bot process will receive this token as an argument, and must send it to the server in this message.
   */
  token: string;
  /** Identifies the protocol version of the bot. */
  protocolVersion: string;
  /** Identify the bot's team side (Team_Home or Team_Away) */
  teamSide: Team_Side;
  /** Player's number 1-11 */
  number: number;
  /** Position where the player must be set at "GetReady" state (at beginning of the match or after a goal) */
  initPosition: Point | undefined;
}

/** GameSnapshot stores all game elements data. */
export interface GameSnapshot {
  /**
   * The game state defines which phase the game is. The phase determine what the server is doing, are going to do, or
   * what it is waiting for.
   */
  state: GameSnapshot_State;
  /** Turns counter. It starts from 1, but before the match starts, it may be zero. */
  turn: number;
  /** Store the home team elements. */
  homeTeam:
    | Team
    | undefined;
  /** Store the away team elements. */
  awayTeam:
    | Team
    | undefined;
  /** Store the ball element. */
  ball:
    | Ball
    | undefined;
  /** number of turns the ball is in a goal zone */
  turnsBallInGoalZone: number;
  /** Store the shot clock to control ball possession limit */
  shotClock: ShotClock | undefined;
}

export enum GameSnapshot_State {
  /**
   * WAITING - The game is waiting for all players be connected. There is a configurable time limit to wait for players. After
   * this limit expires, the match is considered over.
   */
  WAITING = 0,
  /** GET_READY - The game resets the players position to start the match or to restart the match after a goal. */
  GET_READY = 1,
  /**
   * LISTENING - The game is waiting for players orders. There is a configurable time window for this phase. After the time
   * limit expires, the server will ignore the missing orders and process the ones it got.
   * (when running on dev mode, the server may allow different behaviours)
   */
  LISTENING = 2,
  /**
   * PLAYING - The game is executing the players' orders in the same sequence they were gotten.
   * If the ball is NOT been holden, its velocity will be processed first. Otherwise, it position will be updated
   * when the ball holder movement be processed.
   * If there is no movement orders from a player, but it has speed greater than 0, it will be processed after
   * all its orders are processed.
   * Each player orders will be processed in the same sequence they were included in the message (e.g. first move,
   * than kick)
   * The ball kick is processed immediately after the order (the ball position is updated as its new velocity
   * after the kick)
   */
  PLAYING = 3,
  /**
   * SHIFTING - The game interrupt the match to shift the ball possession. It happens only when the shot time is over (see
   * shot_clock property). The ball will be given to the goalkeeper of the defense team, and the next state will
   * "listening", so the bots will not have time to rearrange before the next turn.
   */
  SHIFTING = 4,
  /**
   * OVER - The game may be over after any phase.
   * It can be over after Waiting if there is no players connected after the time limit for connections
   * It can be over after GetReady or Listening if there is no enough players (e.g. connection lost)
   * And it also can be over after Playing state if that was the last turn of the match.
   */
  OVER = 99,
  UNRECOGNIZED = -1,
}

export function gameSnapshot_StateFromJSON(object: any): GameSnapshot_State {
  switch (object) {
    case 0:
    case "WAITING":
      return GameSnapshot_State.WAITING;
    case 1:
    case "GET_READY":
      return GameSnapshot_State.GET_READY;
    case 2:
    case "LISTENING":
      return GameSnapshot_State.LISTENING;
    case 3:
    case "PLAYING":
      return GameSnapshot_State.PLAYING;
    case 4:
    case "SHIFTING":
      return GameSnapshot_State.SHIFTING;
    case 99:
    case "OVER":
      return GameSnapshot_State.OVER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return GameSnapshot_State.UNRECOGNIZED;
  }
}

export function gameSnapshot_StateToJSON(object: GameSnapshot_State): string {
  switch (object) {
    case GameSnapshot_State.WAITING:
      return "WAITING";
    case GameSnapshot_State.GET_READY:
      return "GET_READY";
    case GameSnapshot_State.LISTENING:
      return "LISTENING";
    case GameSnapshot_State.PLAYING:
      return "PLAYING";
    case GameSnapshot_State.SHIFTING:
      return "SHIFTING";
    case GameSnapshot_State.OVER:
      return "OVER";
    case GameSnapshot_State.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Stores all team elements and data. */
export interface Team {
  /** List of player in the team */
  players: Player[];
  /** Team name */
  name: string;
  /** Team score in the present turn */
  score: number;
  /** Side which the team is playing on. */
  side: Team_Side;
}

export enum Team_Side {
  /** HOME - Team playing on the left side of field */
  HOME = 0,
  /** AWAY - Team playing on the right side of the field */
  AWAY = 1,
  UNRECOGNIZED = -1,
}

export function team_SideFromJSON(object: any): Team_Side {
  switch (object) {
    case 0:
    case "HOME":
      return Team_Side.HOME;
    case 1:
    case "AWAY":
      return Team_Side.AWAY;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Team_Side.UNRECOGNIZED;
  }
}

export function team_SideToJSON(object: Team_Side): string {
  switch (object) {
    case Team_Side.HOME:
      return "HOME";
    case Team_Side.AWAY:
      return "AWAY";
    case Team_Side.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * Stores the side of the team in attack and the time remaining holding the ball.
 * The team side is changed as soon a bot of the defense team catch the ball.
 */
export interface ShotClock {
  /** Team side of the team in attack. */
  teamSide: Team_Side;
  /** Remaining turns the attack team may hold the ball */
  remainingTurns: number;
}

/** Stores all player attributes */
export interface Player {
  /** Number of this player in its team (1-11) */
  number: number;
  /** Current player position */
  position:
    | Point
    | undefined;
  /** Current player velocity */
  velocity:
    | Velocity
    | undefined;
  /**
   * Team side which its playing in (it's used to speed up some readings since the player element will be in a list
   * of players of a team)
   */
  teamSide: Team_Side;
  /** Default position when it's position is reset */
  initPosition:
    | Point
    | undefined;
  /** indicates the the player is jumping (goalkeepers only) */
  isJumping: boolean;
}

/** Stores all ball attributes */
export interface Ball {
  /** Current position */
  position:
    | Point
    | undefined;
  /** Current velocity. It will be the exactly same velocity as the ball holder when a player is holding it. */
  velocity:
    | Velocity
    | undefined;
  /** Player that is currently holding the ball. Null if the ball is not holden. */
  holder: Player | undefined;
}

/** Message sent to the player as a response after sending a order set to the the server. */
export interface OrderResponse {
  /** Define if the order will be correctly processed. */
  code: OrderResponse_StatusCode;
  /** String message used for debugging proposes. */
  details: string;
}

export enum OrderResponse_StatusCode {
  SUCCESS = 0,
  UNKNOWN_PLAYER = 1,
  NOT_LISTENING = 2,
  WRONG_TURN = 3,
  OTHER = 99,
  UNRECOGNIZED = -1,
}

export function orderResponse_StatusCodeFromJSON(object: any): OrderResponse_StatusCode {
  switch (object) {
    case 0:
    case "SUCCESS":
      return OrderResponse_StatusCode.SUCCESS;
    case 1:
    case "UNKNOWN_PLAYER":
      return OrderResponse_StatusCode.UNKNOWN_PLAYER;
    case 2:
    case "NOT_LISTENING":
      return OrderResponse_StatusCode.NOT_LISTENING;
    case 3:
    case "WRONG_TURN":
      return OrderResponse_StatusCode.WRONG_TURN;
    case 99:
    case "OTHER":
      return OrderResponse_StatusCode.OTHER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return OrderResponse_StatusCode.UNRECOGNIZED;
  }
}

export function orderResponse_StatusCodeToJSON(object: OrderResponse_StatusCode): string {
  switch (object) {
    case OrderResponse_StatusCode.SUCCESS:
      return "SUCCESS";
    case OrderResponse_StatusCode.UNKNOWN_PLAYER:
      return "UNKNOWN_PLAYER";
    case OrderResponse_StatusCode.NOT_LISTENING:
      return "NOT_LISTENING";
    case OrderResponse_StatusCode.WRONG_TURN:
      return "WRONG_TURN";
    case OrderResponse_StatusCode.OTHER:
      return "OTHER";
    case OrderResponse_StatusCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Message containing the orders the player want to send to the server in that turn. */
export interface OrderSet {
  /** Turn which this order set should be processed at. */
  turn: number;
  /** List of orders in the expected order of execution */
  orders: Order[];
  /** String message used for debugging proposes. */
  debugMessage: string;
}

/** Order to the game server. To be sent by players during the Listening phase. */
export interface Order {
  move?: Move | undefined;
  catch?: Catch | undefined;
  kick?: Kick | undefined;
  jump?: Jump | undefined;
}

/**
 * Order to ask the server to change the player velocity (direction and speed).
 * This order replaces the current player velocity, and the new velocity attribute will be immediately processed
 * in that turn. There is a limit speed to the player. The server will cap the velocity if the request is higher than
 * the limit.
 */
export interface Move {
  /** The nex Velocity */
  velocity: Velocity | undefined;
}

/**
 * Order to try to catch the ball. The player can only catch the ball when the player is touching the ball.
 * Only one catching order can be executed in a turn. So, if more than one player try to catch the ball in the same
 * turn, the first processed catch order will succeed, and the next ones will fail.
 */
export interface Catch {
}

/**
 * The kick order is only executed by the ball holder, and it is processed immediately.
 * Important: The kick velocity is summed to the current ball velocity.
 * The kick speed will suffer a power reduction proportionally to the player direction when the kick is not in the
 * same direction of the player direction. The reduction is calculated based on the angle with the player direction
 * using the formula `SpeedReducerFactor = 0.5 + (0.5 * ((180 - ang) / 180))`
 * In summary, the speed will by reduced proportionally to the angle from 100% at 0 degrees until the limit of
 * 50% at 180 degrees.
 */
export interface Kick {
  /** Kick velocity (it won't be necessarily the final ball velocity) */
  velocity: Velocity | undefined;
}

/**
 * Changes the goalkeepers velocity in a higher speed.
 * The goalkeepers may move kicker than other players when they jump, however the jump movement cannot be interrupted
 * after triggered. (read specs to find out the number of turns the jump lasts)
 */
export interface Jump {
  /** Goalkeeper's velocity during the jump. */
  velocity: Velocity | undefined;
}

function createBaseJoinRequest(): JoinRequest {
  return { token: "", protocolVersion: "", teamSide: 0, number: 0, initPosition: undefined };
}

export const JoinRequest: MessageFns<JoinRequest> = {
  encode(message: JoinRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.protocolVersion !== "") {
      writer.uint32(18).string(message.protocolVersion);
    }
    if (message.teamSide !== 0) {
      writer.uint32(24).int32(message.teamSide);
    }
    if (message.number !== 0) {
      writer.uint32(32).uint32(message.number);
    }
    if (message.initPosition !== undefined) {
      Point.encode(message.initPosition, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.protocolVersion = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.teamSide = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.number = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initPosition = Point.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinRequest {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      protocolVersion: isSet(object.protocolVersion) ? globalThis.String(object.protocolVersion) : "",
      teamSide: isSet(object.teamSide) ? team_SideFromJSON(object.teamSide) : 0,
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
      initPosition: isSet(object.initPosition) ? Point.fromJSON(object.initPosition) : undefined,
    };
  },

  toJSON(message: JoinRequest): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.protocolVersion !== "") {
      obj.protocolVersion = message.protocolVersion;
    }
    if (message.teamSide !== 0) {
      obj.teamSide = team_SideToJSON(message.teamSide);
    }
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.initPosition !== undefined) {
      obj.initPosition = Point.toJSON(message.initPosition);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<JoinRequest>, I>>(base?: I): JoinRequest {
    return JoinRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<JoinRequest>, I>>(object: I): JoinRequest {
    const message = createBaseJoinRequest();
    message.token = object.token ?? "";
    message.protocolVersion = object.protocolVersion ?? "";
    message.teamSide = object.teamSide ?? 0;
    message.number = object.number ?? 0;
    message.initPosition = (object.initPosition !== undefined && object.initPosition !== null)
      ? Point.fromPartial(object.initPosition)
      : undefined;
    return message;
  },
};

function createBaseGameSnapshot(): GameSnapshot {
  return {
    state: 0,
    turn: 0,
    homeTeam: undefined,
    awayTeam: undefined,
    ball: undefined,
    turnsBallInGoalZone: 0,
    shotClock: undefined,
  };
}

export const GameSnapshot: MessageFns<GameSnapshot> = {
  encode(message: GameSnapshot, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    if (message.turn !== 0) {
      writer.uint32(16).uint32(message.turn);
    }
    if (message.homeTeam !== undefined) {
      Team.encode(message.homeTeam, writer.uint32(26).fork()).join();
    }
    if (message.awayTeam !== undefined) {
      Team.encode(message.awayTeam, writer.uint32(34).fork()).join();
    }
    if (message.ball !== undefined) {
      Ball.encode(message.ball, writer.uint32(42).fork()).join();
    }
    if (message.turnsBallInGoalZone !== 0) {
      writer.uint32(48).uint32(message.turnsBallInGoalZone);
    }
    if (message.shotClock !== undefined) {
      ShotClock.encode(message.shotClock, writer.uint32(58).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GameSnapshot {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGameSnapshot();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.turn = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.homeTeam = Team.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.awayTeam = Team.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ball = Ball.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.turnsBallInGoalZone = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.shotClock = ShotClock.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GameSnapshot {
    return {
      state: isSet(object.state) ? gameSnapshot_StateFromJSON(object.state) : 0,
      turn: isSet(object.turn) ? globalThis.Number(object.turn) : 0,
      homeTeam: isSet(object.homeTeam) ? Team.fromJSON(object.homeTeam) : undefined,
      awayTeam: isSet(object.awayTeam) ? Team.fromJSON(object.awayTeam) : undefined,
      ball: isSet(object.ball) ? Ball.fromJSON(object.ball) : undefined,
      turnsBallInGoalZone: isSet(object.turnsBallInGoalZone) ? globalThis.Number(object.turnsBallInGoalZone) : 0,
      shotClock: isSet(object.shotClock) ? ShotClock.fromJSON(object.shotClock) : undefined,
    };
  },

  toJSON(message: GameSnapshot): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = gameSnapshot_StateToJSON(message.state);
    }
    if (message.turn !== 0) {
      obj.turn = Math.round(message.turn);
    }
    if (message.homeTeam !== undefined) {
      obj.homeTeam = Team.toJSON(message.homeTeam);
    }
    if (message.awayTeam !== undefined) {
      obj.awayTeam = Team.toJSON(message.awayTeam);
    }
    if (message.ball !== undefined) {
      obj.ball = Ball.toJSON(message.ball);
    }
    if (message.turnsBallInGoalZone !== 0) {
      obj.turnsBallInGoalZone = Math.round(message.turnsBallInGoalZone);
    }
    if (message.shotClock !== undefined) {
      obj.shotClock = ShotClock.toJSON(message.shotClock);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GameSnapshot>, I>>(base?: I): GameSnapshot {
    return GameSnapshot.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GameSnapshot>, I>>(object: I): GameSnapshot {
    const message = createBaseGameSnapshot();
    message.state = object.state ?? 0;
    message.turn = object.turn ?? 0;
    message.homeTeam = (object.homeTeam !== undefined && object.homeTeam !== null)
      ? Team.fromPartial(object.homeTeam)
      : undefined;
    message.awayTeam = (object.awayTeam !== undefined && object.awayTeam !== null)
      ? Team.fromPartial(object.awayTeam)
      : undefined;
    message.ball = (object.ball !== undefined && object.ball !== null) ? Ball.fromPartial(object.ball) : undefined;
    message.turnsBallInGoalZone = object.turnsBallInGoalZone ?? 0;
    message.shotClock = (object.shotClock !== undefined && object.shotClock !== null)
      ? ShotClock.fromPartial(object.shotClock)
      : undefined;
    return message;
  },
};

function createBaseTeam(): Team {
  return { players: [], name: "", score: 0, side: 0 };
}

export const Team: MessageFns<Team> = {
  encode(message: Team, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.players) {
      Player.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.score !== 0) {
      writer.uint32(24).uint32(message.score);
    }
    if (message.side !== 0) {
      writer.uint32(32).int32(message.side);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Team {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTeam();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.players.push(Player.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.score = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.side = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Team {
    return {
      players: globalThis.Array.isArray(object?.players) ? object.players.map((e: any) => Player.fromJSON(e)) : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
      side: isSet(object.side) ? team_SideFromJSON(object.side) : 0,
    };
  },

  toJSON(message: Team): unknown {
    const obj: any = {};
    if (message.players?.length) {
      obj.players = message.players.map((e) => Player.toJSON(e));
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.score !== 0) {
      obj.score = Math.round(message.score);
    }
    if (message.side !== 0) {
      obj.side = team_SideToJSON(message.side);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Team>, I>>(base?: I): Team {
    return Team.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Team>, I>>(object: I): Team {
    const message = createBaseTeam();
    message.players = object.players?.map((e) => Player.fromPartial(e)) || [];
    message.name = object.name ?? "";
    message.score = object.score ?? 0;
    message.side = object.side ?? 0;
    return message;
  },
};

function createBaseShotClock(): ShotClock {
  return { teamSide: 0, remainingTurns: 0 };
}

export const ShotClock: MessageFns<ShotClock> = {
  encode(message: ShotClock, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.teamSide !== 0) {
      writer.uint32(48).int32(message.teamSide);
    }
    if (message.remainingTurns !== 0) {
      writer.uint32(56).uint32(message.remainingTurns);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShotClock {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShotClock();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.teamSide = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.remainingTurns = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShotClock {
    return {
      teamSide: isSet(object.teamSide) ? team_SideFromJSON(object.teamSide) : 0,
      remainingTurns: isSet(object.remainingTurns) ? globalThis.Number(object.remainingTurns) : 0,
    };
  },

  toJSON(message: ShotClock): unknown {
    const obj: any = {};
    if (message.teamSide !== 0) {
      obj.teamSide = team_SideToJSON(message.teamSide);
    }
    if (message.remainingTurns !== 0) {
      obj.remainingTurns = Math.round(message.remainingTurns);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ShotClock>, I>>(base?: I): ShotClock {
    return ShotClock.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ShotClock>, I>>(object: I): ShotClock {
    const message = createBaseShotClock();
    message.teamSide = object.teamSide ?? 0;
    message.remainingTurns = object.remainingTurns ?? 0;
    return message;
  },
};

function createBasePlayer(): Player {
  return {
    number: 0,
    position: undefined,
    velocity: undefined,
    teamSide: 0,
    initPosition: undefined,
    isJumping: false,
  };
}

export const Player: MessageFns<Player> = {
  encode(message: Player, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.number !== 0) {
      writer.uint32(8).uint32(message.number);
    }
    if (message.position !== undefined) {
      Point.encode(message.position, writer.uint32(18).fork()).join();
    }
    if (message.velocity !== undefined) {
      Velocity.encode(message.velocity, writer.uint32(26).fork()).join();
    }
    if (message.teamSide !== 0) {
      writer.uint32(32).int32(message.teamSide);
    }
    if (message.initPosition !== undefined) {
      Point.encode(message.initPosition, writer.uint32(42).fork()).join();
    }
    if (message.isJumping !== false) {
      writer.uint32(48).bool(message.isJumping);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Player {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePlayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.number = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.position = Point.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.velocity = Velocity.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.teamSide = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.initPosition = Point.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.isJumping = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Player {
    return {
      number: isSet(object.number) ? globalThis.Number(object.number) : 0,
      position: isSet(object.position) ? Point.fromJSON(object.position) : undefined,
      velocity: isSet(object.velocity) ? Velocity.fromJSON(object.velocity) : undefined,
      teamSide: isSet(object.teamSide) ? team_SideFromJSON(object.teamSide) : 0,
      initPosition: isSet(object.initPosition) ? Point.fromJSON(object.initPosition) : undefined,
      isJumping: isSet(object.isJumping) ? globalThis.Boolean(object.isJumping) : false,
    };
  },

  toJSON(message: Player): unknown {
    const obj: any = {};
    if (message.number !== 0) {
      obj.number = Math.round(message.number);
    }
    if (message.position !== undefined) {
      obj.position = Point.toJSON(message.position);
    }
    if (message.velocity !== undefined) {
      obj.velocity = Velocity.toJSON(message.velocity);
    }
    if (message.teamSide !== 0) {
      obj.teamSide = team_SideToJSON(message.teamSide);
    }
    if (message.initPosition !== undefined) {
      obj.initPosition = Point.toJSON(message.initPosition);
    }
    if (message.isJumping !== false) {
      obj.isJumping = message.isJumping;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Player>, I>>(base?: I): Player {
    return Player.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Player>, I>>(object: I): Player {
    const message = createBasePlayer();
    message.number = object.number ?? 0;
    message.position = (object.position !== undefined && object.position !== null)
      ? Point.fromPartial(object.position)
      : undefined;
    message.velocity = (object.velocity !== undefined && object.velocity !== null)
      ? Velocity.fromPartial(object.velocity)
      : undefined;
    message.teamSide = object.teamSide ?? 0;
    message.initPosition = (object.initPosition !== undefined && object.initPosition !== null)
      ? Point.fromPartial(object.initPosition)
      : undefined;
    message.isJumping = object.isJumping ?? false;
    return message;
  },
};

function createBaseBall(): Ball {
  return { position: undefined, velocity: undefined, holder: undefined };
}

export const Ball: MessageFns<Ball> = {
  encode(message: Ball, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.position !== undefined) {
      Point.encode(message.position, writer.uint32(10).fork()).join();
    }
    if (message.velocity !== undefined) {
      Velocity.encode(message.velocity, writer.uint32(18).fork()).join();
    }
    if (message.holder !== undefined) {
      Player.encode(message.holder, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ball {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseBall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.position = Point.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.velocity = Velocity.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.holder = Player.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ball {
    return {
      position: isSet(object.position) ? Point.fromJSON(object.position) : undefined,
      velocity: isSet(object.velocity) ? Velocity.fromJSON(object.velocity) : undefined,
      holder: isSet(object.holder) ? Player.fromJSON(object.holder) : undefined,
    };
  },

  toJSON(message: Ball): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Point.toJSON(message.position);
    }
    if (message.velocity !== undefined) {
      obj.velocity = Velocity.toJSON(message.velocity);
    }
    if (message.holder !== undefined) {
      obj.holder = Player.toJSON(message.holder);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ball>, I>>(base?: I): Ball {
    return Ball.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ball>, I>>(object: I): Ball {
    const message = createBaseBall();
    message.position = (object.position !== undefined && object.position !== null)
      ? Point.fromPartial(object.position)
      : undefined;
    message.velocity = (object.velocity !== undefined && object.velocity !== null)
      ? Velocity.fromPartial(object.velocity)
      : undefined;
    message.holder = (object.holder !== undefined && object.holder !== null)
      ? Player.fromPartial(object.holder)
      : undefined;
    return message;
  },
};

function createBaseOrderResponse(): OrderResponse {
  return { code: 0, details: "" };
}

export const OrderResponse: MessageFns<OrderResponse> = {
  encode(message: OrderResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.details !== "") {
      writer.uint32(18).string(message.details);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.details = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderResponse {
    return {
      code: isSet(object.code) ? orderResponse_StatusCodeFromJSON(object.code) : 0,
      details: isSet(object.details) ? globalThis.String(object.details) : "",
    };
  },

  toJSON(message: OrderResponse): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = orderResponse_StatusCodeToJSON(message.code);
    }
    if (message.details !== "") {
      obj.details = message.details;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderResponse>, I>>(base?: I): OrderResponse {
    return OrderResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderResponse>, I>>(object: I): OrderResponse {
    const message = createBaseOrderResponse();
    message.code = object.code ?? 0;
    message.details = object.details ?? "";
    return message;
  },
};

function createBaseOrderSet(): OrderSet {
  return { turn: 0, orders: [], debugMessage: "" };
}

export const OrderSet: MessageFns<OrderSet> = {
  encode(message: OrderSet, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.turn !== 0) {
      writer.uint32(8).uint32(message.turn);
    }
    for (const v of message.orders) {
      Order.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.debugMessage !== "") {
      writer.uint32(26).string(message.debugMessage);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrderSet {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrderSet();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.turn = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.orders.push(Order.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.debugMessage = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrderSet {
    return {
      turn: isSet(object.turn) ? globalThis.Number(object.turn) : 0,
      orders: globalThis.Array.isArray(object?.orders) ? object.orders.map((e: any) => Order.fromJSON(e)) : [],
      debugMessage: isSet(object.debugMessage) ? globalThis.String(object.debugMessage) : "",
    };
  },

  toJSON(message: OrderSet): unknown {
    const obj: any = {};
    if (message.turn !== 0) {
      obj.turn = Math.round(message.turn);
    }
    if (message.orders?.length) {
      obj.orders = message.orders.map((e) => Order.toJSON(e));
    }
    if (message.debugMessage !== "") {
      obj.debugMessage = message.debugMessage;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrderSet>, I>>(base?: I): OrderSet {
    return OrderSet.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrderSet>, I>>(object: I): OrderSet {
    const message = createBaseOrderSet();
    message.turn = object.turn ?? 0;
    message.orders = object.orders?.map((e) => Order.fromPartial(e)) || [];
    message.debugMessage = object.debugMessage ?? "";
    return message;
  },
};

function createBaseOrder(): Order {
  return { move: undefined, catch: undefined, kick: undefined, jump: undefined };
}

export const Order: MessageFns<Order> = {
  encode(message: Order, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.move !== undefined) {
      Move.encode(message.move, writer.uint32(10).fork()).join();
    }
    if (message.catch !== undefined) {
      Catch.encode(message.catch, writer.uint32(18).fork()).join();
    }
    if (message.kick !== undefined) {
      Kick.encode(message.kick, writer.uint32(26).fork()).join();
    }
    if (message.jump !== undefined) {
      Jump.encode(message.jump, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Order {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrder();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.move = Move.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.catch = Catch.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.kick = Kick.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.jump = Jump.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Order {
    return {
      move: isSet(object.move) ? Move.fromJSON(object.move) : undefined,
      catch: isSet(object.catch) ? Catch.fromJSON(object.catch) : undefined,
      kick: isSet(object.kick) ? Kick.fromJSON(object.kick) : undefined,
      jump: isSet(object.jump) ? Jump.fromJSON(object.jump) : undefined,
    };
  },

  toJSON(message: Order): unknown {
    const obj: any = {};
    if (message.move !== undefined) {
      obj.move = Move.toJSON(message.move);
    }
    if (message.catch !== undefined) {
      obj.catch = Catch.toJSON(message.catch);
    }
    if (message.kick !== undefined) {
      obj.kick = Kick.toJSON(message.kick);
    }
    if (message.jump !== undefined) {
      obj.jump = Jump.toJSON(message.jump);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Order>, I>>(base?: I): Order {
    return Order.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Order>, I>>(object: I): Order {
    const message = createBaseOrder();
    message.move = (object.move !== undefined && object.move !== null) ? Move.fromPartial(object.move) : undefined;
    message.catch = (object.catch !== undefined && object.catch !== null) ? Catch.fromPartial(object.catch) : undefined;
    message.kick = (object.kick !== undefined && object.kick !== null) ? Kick.fromPartial(object.kick) : undefined;
    message.jump = (object.jump !== undefined && object.jump !== null) ? Jump.fromPartial(object.jump) : undefined;
    return message;
  },
};

function createBaseMove(): Move {
  return { velocity: undefined };
}

export const Move: MessageFns<Move> = {
  encode(message: Move, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.velocity !== undefined) {
      Velocity.encode(message.velocity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Move {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMove();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.velocity = Velocity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Move {
    return { velocity: isSet(object.velocity) ? Velocity.fromJSON(object.velocity) : undefined };
  },

  toJSON(message: Move): unknown {
    const obj: any = {};
    if (message.velocity !== undefined) {
      obj.velocity = Velocity.toJSON(message.velocity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Move>, I>>(base?: I): Move {
    return Move.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Move>, I>>(object: I): Move {
    const message = createBaseMove();
    message.velocity = (object.velocity !== undefined && object.velocity !== null)
      ? Velocity.fromPartial(object.velocity)
      : undefined;
    return message;
  },
};

function createBaseCatch(): Catch {
  return {};
}

export const Catch: MessageFns<Catch> = {
  encode(_: Catch, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Catch {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCatch();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Catch {
    return {};
  },

  toJSON(_: Catch): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Catch>, I>>(base?: I): Catch {
    return Catch.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Catch>, I>>(_: I): Catch {
    const message = createBaseCatch();
    return message;
  },
};

function createBaseKick(): Kick {
  return { velocity: undefined };
}

export const Kick: MessageFns<Kick> = {
  encode(message: Kick, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.velocity !== undefined) {
      Velocity.encode(message.velocity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Kick {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseKick();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.velocity = Velocity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Kick {
    return { velocity: isSet(object.velocity) ? Velocity.fromJSON(object.velocity) : undefined };
  },

  toJSON(message: Kick): unknown {
    const obj: any = {};
    if (message.velocity !== undefined) {
      obj.velocity = Velocity.toJSON(message.velocity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Kick>, I>>(base?: I): Kick {
    return Kick.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Kick>, I>>(object: I): Kick {
    const message = createBaseKick();
    message.velocity = (object.velocity !== undefined && object.velocity !== null)
      ? Velocity.fromPartial(object.velocity)
      : undefined;
    return message;
  },
};

function createBaseJump(): Jump {
  return { velocity: undefined };
}

export const Jump: MessageFns<Jump> = {
  encode(message: Jump, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.velocity !== undefined) {
      Velocity.encode(message.velocity, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Jump {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJump();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.velocity = Velocity.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Jump {
    return { velocity: isSet(object.velocity) ? Velocity.fromJSON(object.velocity) : undefined };
  },

  toJSON(message: Jump): unknown {
    const obj: any = {};
    if (message.velocity !== undefined) {
      obj.velocity = Velocity.toJSON(message.velocity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Jump>, I>>(base?: I): Jump {
    return Jump.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Jump>, I>>(object: I): Jump {
    const message = createBaseJump();
    message.velocity = (object.velocity !== undefined && object.velocity !== null)
      ? Velocity.fromPartial(object.velocity)
      : undefined;
    return message;
  },
};

/** Service provided by the game service to the players (clients). */
export interface Game {
  /** JoinATeam allows the player to listen the server during the match. */
  JoinATeam(request: JoinRequest): Observable<GameSnapshot>;
  /** SendOrders allows the player to send others to the server when the game is on listening state. */
  SendOrders(request: OrderSet): Promise<OrderResponse>;
}

export const GameServiceName = "lugo.Game";
export class GameClientImpl implements Game {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || GameServiceName;
    this.rpc = rpc;
    this.JoinATeam = this.JoinATeam.bind(this);
    this.SendOrders = this.SendOrders.bind(this);
  }
  JoinATeam(request: JoinRequest): Observable<GameSnapshot> {
    const data = JoinRequest.encode(request).finish();
    const result = this.rpc.serverStreamingRequest(this.service, "JoinATeam", data);
    return result.pipe(map((data) => GameSnapshot.decode(new BinaryReader(data))));
  }

  SendOrders(request: OrderSet): Promise<OrderResponse> {
    const data = OrderSet.encode(request).finish();
    const promise = this.rpc.request(this.service, "SendOrders", data);
    return promise.then((data) => OrderResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
  clientStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Promise<Uint8Array>;
  serverStreamingRequest(service: string, method: string, data: Uint8Array): Observable<Uint8Array>;
  bidirectionalStreamingRequest(service: string, method: string, data: Observable<Uint8Array>): Observable<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
